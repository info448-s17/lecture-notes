[
["index.html", "Android Development: Lecture Notes About this Book", " Android Development: Lecture Notes Joel Ross 2017-05-01 About this Book This book compiles lecture notes and tutorials for the INFO 448 Mobile Development: Android course taught at the University of Washington Information School (most recently in Spring 2017). The goal of these notes is to provide learning materials for students in the course or anyone else who wishes to learn the basics of developing Android applications. These notes are primarily adapted from the official Android developer documentation, compiling and synthesizing those guidelines for pedagogical purposes (and the author’s own interpretation/biases). Please refer to that documentation for the latest information and official guidance. This book is currently in alpha status, as pure lecture notes are converted into more generic formats. This book is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],
["introduction.html", "Lecture 1 Introduction 1.1 Android History 1.2 Android Architecture and Code 1.3 Development Tools 1.4 Hello World", " Lecture 1 Introduction This course focuses on Android Development. But what is Android? Android is an operating system. That is, it’s software that connects hardware to software and provides general services. But more than that, it’s a mobile specific operating system: an OS designed to work on mobile (read: handheld, wearable, carry-able) devices. Note that the term “Android” also is used to refer to the “platform” (e.g., devices that use the OS) as well as the ecosystem that surrounds it. This includes the device manufacturers who use the platform, and the applications that can be built and run on this platform. So “Android Development” technically means developing applications that run on the specific OS, it also gets generalized to refer to developing any kind of software that interacts with the platform. 1.1 Android History If you’re going to develop systems for Android, it’s good to have some familiarity with the platform and its history, if only to give you perspective on how and why the framework is designed the way it is. 2003: The platform was originally founded by a start-up “Android Inc.” which aimed to build a mobile OS operating system (similar to what Nokia’s Symbian was doing at the time) 2005: Android was acquired by Google, who was looking to get into mobile 2007: Google announces the Open Handset Alliance, a group of tech companies working together to develop “open standards” for mobile platforms. Members included phone manufacturers like HTC, Samsung, and Sony; mobile carriers like T-Mobile, Sprint, and NTT DoCoMo; hardware manufacturers like Broadcom and Nvidia; and others. The Open Handset Alliance now (2017) includes 86 companies. Note this is the same year the first iPhone came out! 2008: First Android device is released: the HTC Dream (a.k.a. T-Mobile G1) Specs: 528Mhz ARM chip; 256MB memory; 320x480 resolution capacitive touch; slide-out keyboard! Author’s opinion: a fun little device. 2010: First Nexus device is released: the Nexus One. These are Google-developed “flagship” devices, intended to show off the capabilities of the platform. Specs: 1Ghz Scorpion; 512MB memory; .37&quot; at 480x800 AMOLED capacitive touch. For comparison, the iPhone 7 Plus (2016) has: 2.34Ghz dual core A10 64bit Fusion; 3GB RAM; 5.5&quot; at 1920x1080 display. As of 2016, this program has been superceded by the Pixel range of devices. 2014: Android Wear, a version of Android for wearable devices (watches) is announced. 2016: Daydream, a virtual reality (VR) platform for Android is announced In short, Google keeps pushing the platform wider so it includes more and more capabilities. Today, Android is incredibly popular (to put it mildly). Android is incredibly popular! (see e.g., here, here, and here) In any of these analyses there are some questions about what exactly is counted… but what we care about is that there are a lot of Android devices out there! And more than that: there are a lot of different devices! 1.1.1 Android Versions Android has gone through a large number of “versions” since it’s release: Date Version Nickname API Level Sep 2008 1.0 Android 1 Apr 2009 1.5 Cupcake 3 Sep 2009 1.6 Donut 4 Oct 2009 2.0 Eclair 5 May 2010 2.2 Froyo 8 Dec 2010 2.3 Gingerbread 9 Feb 2011 3.0 Honeycomb 11 Oct 2011 4.0 Ice Cream Sandwich 14 July 2012 4.1 Jelly Bean 16 Oct 2013 4.4 KitKat 19 Nov 2014 5.0 Lollipop 21 Oct 2015 6.0 Marshmallow 23 Aug 2016 7.0 Nougat 24 Mar 2017 O preview Android O Developer Preview Each different “version” is nicknamed after a dessert, in alphabetica order. But as developers, what we care about is the API Level, which indicates what different programming interfaces (classes and methods) are available to use. You can check out an interactive version of the history through Marshmallow at https://www.android.com/history/ For current usage breakdown, see https://developer.android.com/about/dashboards/ Additionally, Android is an “open source” project released through the “Android Open Source Project”, or ASOP. You can find the latest version of the operating system code at https://source.android.com/; it is very worthwhile to actually dig around in the source code sometimes! While new versions are released fairly often, this doesn’t mean that all or even many devices update to the latest version. Instead, users get updated phones historically by purchasing new devices (every 18m on average in US). Beyond that, updates—including security updates—have to come through the mobile carriers, meaning that most devices are never updated beyond the version that they are purchases with. This is a problem from a consumer perspective, particularly in terms of security! There are some efforts on Google’s part to to work around this limitation by moving more and more platform services out of the base operating system into a separate “App” called Google Play Services. But what this means for developers is that you can’t expect devices to be running the latest version of the operating system—the range of versions you need to support is much greater than even web development! 1.1.2 Legal Battles When discussing Android history, we would be remiss if we didn’t mention some of the legal battles surrounding Android. The biggest of these is Oracle v Google. In a nutshell, Oracle claims that the Java API is copyrighted (that the method signatures themeselves and how they work are protected), so because Google uses that API in Android, Google is violating the copyright. In 2012 a California federal judge decided in Google favor (that one can’t copyright an API). This was then reversed by the Federal Circuit court in 2014. The verdict was appealed to the Supreme courset in 2015, who refused to hear the case. It then went back to the the district court, which ruled that Google’s use of the API was fair use. See https://www.eff.org/cases/oracle-v-google for a summary, as well as https://arstechnica.com/series/series-oracle-v-google/ One interesting side effect of this battle: the latest version of Android (Nougat) uses the OpenJDK implementation of Java, instead of Google’s own in-violation-but-fair-use implementation see here. This change shouldn’t have any impact on us as developers, but it’s worth keeping an eye out for potentially differences between Android and Java SE. There have been other legal challenges as well. While not directly about Android, the other major relevant court battle is Apple v Samsung. In this case, Apple claims that Samsung infringed on their intellectual property (their design patents). This has gone back and forth in terms of damages and what is considered infringing; the latest development is that the Supreme Court heard the case and sided with Samsung that infringing design patents shouldn’t lead to damages in terms of the entire device… it’s complicated (the author is not a lawyer). So overall: Android is a growing, evolving platform that is embedded in and affecting the social infrastructures around information technology in numerous ways. 1.2 Android Architecture and Code Developing Android applications involves interfacing with the Android platform and framework. Thus you need a high level understanding of the architecture of the Android platform. See https://source.android.com/devices/ for more details. Android Architecture (image from: hub4tech) Like so many other systems, the Android platform is built as a layered architecture: At it’s base, Android runs on a Linux kernel for interacting with the device’s processor, memory, etc. Thus an Android device can be seen as a Linux computer. On top of that kernel is the Hardware Abstraction Layer: an interface to drivers that can programmatically access hardware elements, such as the camera, disk storage, Wifi antenna, etc. These drivers are generally written in C; we won’t interact with them directly in this course. On top of the HAL is the Runtime and Android Framework, which provides a set of abstraction in the Java language which we all know an love. For this course, Android Development will involve writing Java applications that interact with the Android Framework layer, which handles the task of interacting with the device hardware for us. 1.2.1 Programming Languages There are two programming languages we will be working with in this course: Java: Android code (program control and logic, as well as data storage and manipulation) is written in Java. Writing Android code will feel a lot writing any other Java program: you create classes, define methods, instantiate objects, and call methods on those objects. But because you’re working within a framework, there is a set of code that already exists to call specific methods. As a developer, your task will be to fill in what these methods do in order to run your specific application. In web terms, this is closer to working with Angular (a framework) than jQuery (a library). Importantly: this course expects you to have “journeyman”-level skills in Java (apprenticeship done, not yet master). We’ll be using a number of intermediate concepts (like generics and inheritance) without much fanfare or explanation (though see the appendix). XML: Android user interfaces and resources are specified in XML (EXtensible Markup Language). To compare to web programming: the XML contains what would normally go in the HTML/CSS, while the Java code will contain what would normally go in the JavaScript. XML is just like HTML, but you get to make up your own tags. Except we’ll be using the ones that Android made up; so it’s like defining web pages, except with a new set of elements. This course expects you to have some familiarity with HTML or XML, but if not you should be able to infer what you need from the examples. 1.2.2 Building Apps As stated above, we will write code in Java and XML. But how does that code get run on the phone’s hardware? Pre-Lollipop (5.0), Android code ran on Dalvik: a virtual machine similar to the JVM used by Java SE. Fun fact for people with a Computer Science background: Dalvik uses a register-based architecture rather than a stack-based one! A developer would write Java code, which would then be compiled into JVM bytecode, which would then be translated into DVM (Dalvik virtual machine) bytecode, that could be run on Android devices. This DVM bytecode was stored in .dex or .odex (“[Optimized] Dalvik Executable”) files, which is what was loaded onto the device. The process of converting from Jave code to dex files is called “dexing” (so code that has been built is “dexed”). Dalvik does include JIT (“Just In Time”) compilation to native code that runs much faster than the code interpreted by the virtual machine, similar to the Java HotSpot. This navite code is faster because no translation step is needed to talk to the actual hardware (the OS). From Lollipop (5.0) on, Android instead uses Android Runtime (ART) to run code. ART’s biggest benefit is that it compiles the .dex bytecode into native code on installation using AOT (“Ahead of Time”) compilation. ART continues to accept .dex bytecode for backwards compatibility (so the same dexing process occurs), but the code that is actually installed and run on a device is native. This allows for applications to have faster execution, but at the cost of longer install times—but since you only install an application once, this is a pretty good trade. After being built, Android applications (the source, dexed bytecode, and any resources) are packaged into .apk files. These are basically zip files (they use the same gzip compression); if you rename the file to be .zip and you can unpackage them! The .apk files are then cryptographically signed to specify their authenticity, and either “side-loaded” onto the device or uploaded to an App Store for deployment. The signed .apk files are basically the “executable” versions of your program! Note that the Android application framework code is actually “pre-DEXed” (pre-compiled) on the device; when you write code, you’re actually compiling against empty code stubs (rather than needing to include those classes in your .apk)! That said, any other 3rd-party libraries you include will be copied into your built App, which can increase its file size both for installation and on the device. To summarize, in addition to writing Java and XML code, when building an App you need to: Generate Java source files (e.g., from resource files, which are written XML used to generate Java code) Compile Java code into JVM bytecode “dex” the JVM bytecode into Dalvik bytecode Pack in assets and graphics into an APK Cryptographically sign the APK file to verify it Load it onto the device There are a lot of steps here, but there are tools that take care of it for us. We’ll just write Java and XML code and run a “build” script to do all of the steps! 1.3 Development Tools There are a number of different hardware and software tools you will need to do Android development: 1.3.1 Hardware Since Android code is written for a virtual machine anyway, Android apps can be developed and built on any computer’s operating system (unlike some other mobile OS…). But obviously Android apps will need to be run on Android devices. Physical devices are the best for development (they are the fastest, easiest way to test), though you’ll need USB cable to be able to wire your device into your computer. Any device will work for this course; you don’t even need cellular service (just WiFi should work). Note that if you are unfamiliar with Android devices, you should be sure to play around with the interface to get used to the interaction language, e.g., how to click/swipe/drag/long-click elements to use an app. You will need to turn on developer options in order to install development apps on your device! If you don’t have a physical device, it is also possible to use the Android Emulator, which is a “virtual” Android device. The emulator represents a generic device with hardware you can specify… but it does have some limitations (e.g., no cellular service, no bluetooth, etc). While it has improved recently, the Emulator historically does not work very well on Windows; I recommend you develop on either a Mac or a physical device. In either case, make sure you have enabled HAXM (Intel’s Acceleration Manager, which allows the emulator to utilize your GPU for rendering): this speeds things up considerably. 1.3.2 Software Software needed to develop Android applications includes: The Java 7 SDK (not just the JRE!) This is because you’re writing Java code! Gradle or Apache ANT. These are automated build tools—in effect, they let you specify a single command that will do a bunch of steps at once (e.g., compile files, dex files, move files, etc). These are how we make the “build script” that does the 6 build steps listed above. ANT is the “old” build system, Gradle is the “modern” build system (and so what we will be focusing on). Note that you do not need to install Gradle separately for this course. Android Studio &amp; Android SDK is the official IDE for developing Android applications. Note that the IDE comes bundled with the SDK. Android Studio provides the main build system: all of the other software (Java, Gradle) goes to support this. The SDK comes with a number of useful command-line tools. These include: adb, the “Android Device Bridge”, which is a connection between your computer and the device (physical or virtual). This tool is used for console output! emulator, which is a tool used to run the Android emulator deprecated/removed android: a tool that does SDK/AVD (Android Virtual Device) management. Basically, this command-line utility did everything that the IDE did, but from the command-line! It has recently been removed from the IDE. I recommend making sure that the SDK command-line tools are installed. Put the tools and platform-tools folders on your computer’s PATH; you can run adb to check that everything works. All of these tools are built into the IDE, but they can be useful fallbacks for debugging. 1.4 Hello World As a final introductory steps, this lecture will walk you through creating and running a basic App so that you can see what you will actually be working with. You will need to have Android Studio installed for this to work. Launch Android Studio if you have it (may take a few minutes to open) Start a new project. Use your UW NetID in the domain. Make a mental note of the project location so you can find your code later! Target: this is the “minimum” SDK you support. We’re going to target Ice Cream Sandwich (4.0.3, API 15) for most this class, as the earliest version of Android most our apps will support. Note that this is different than the “target SDK”, which is the version of Android you tested your application against (e.g., what system did you run it on?) For this course we will be testing on API 21 (Lollipop); we’ll specify that in a moment. Select an Empty Activity Activities are “Screens” in your application (things the user can do). Activities are discussed in more detail in the next lecture. And boom, you have an Android app! Aren’t frameworks lovely? 1.4.1 The Emulator We can run our app by clicking the “Play” or “Run” button at the top of the IDE. But we’ll need a device to run the app on, so let’s make an emulator! The Nexus 5 is a good choice for supporting “older” devices. The new Pixel is also a reasonable device to test against. You’ll want to make sure you create a Lollipop device, using the Google APIs (so we have special classes available to us), and amost certainly running on x86 (Intel) hardware Make sure that you’ve specified that it accepts keyboard input. You can always edit this emulator later (Tools &gt; Android &gt; AVD Manager). After the emulator boots, you can slide to unlock, and there is our app! 1.4.2 Project Contents So what does our app look like in code? What do we have? Note that Android Studio by default shows the “Android” view, which organizes files thematically. If you go to the “Project” view you can see what the actual file system looks like. In Android view, files are organized as follows: app/ folder contains our application manifests/ contains the Android Manifest files, which is sort of like a “config” file for the app java/ contains the Java source code for your project. You can find the MyActivity file in here res/ contains resource files used in the app. These are where we’re going to put layout/appearance information Also have the Gradle scripts. There are a lot of these: build.gradle: Top-level Gradle build; project-level (for building!) app/build.gradle: Gradle build specific to the app use this one to customize project!. We can change the Target SDK in here! proguard-rules.pro: config for release version (minimization, obfuscation, etc). gradle.properties: Gradle-specific build settings, shared local.properties: settings local to this machine only settings.gradle: Gradle-specific build settings, shared Note that ANT would instead give: build.xml: Ant build script integrated with Android SDK build.properties: settings used for build across all machines local.properties: settings local to this machine only We’re using Gradle, but it is good to be aware of ANT stuff for legacy purposes res has resource files. These are XML files that specify details of the app–such as layout. res/drawable/: contains graphics (PNG, JPEG, etc) res/layout/: contains UI XML layout files res/mipmap/: conatins launcher icon files in different resolutions Fun fact: MIP stands for “multum in parvo”, which is Latin for “much in little” (because multiple resolutions of the images are stored in a single file). “Map” is used because Mipmaps are normally used for texture mapping. res/values/: contains XML definitions for general constants See also: http://developer.android.com/guide/topics/resources/available-resources.html, or Lecture 3. We can also consider what the application code does. While we’ll revisit this in more detail in the next lecture, it’s useful to start seeing how the framework is structured: We’ll start with the MyActivity Java source file. This class extends Activity (actually it extends a subclass that supports Material Design components), allowing us making our own customizations to what the app does. In this class, we override the onCreate() method that is called by the framework when the Activity starts (see next lecture). We call the super method, and then setContentView() to specify what the content (appearance) of our Activity is. This is passed in a value from something called R. R is a class that is generated at compile time and contains constants that are defined by the XML “resource” files! Those files are converted into Java variables, which we can access through the R class. R.layout refers to the “layout” XML resource, so can go there (remember: inside res/). Opening these XML files they appear in a “design” view. This view lets you use a graphical system to lay out your application (similar to a PowerPoint slide). However, even as the design view becomes more powerful, using it is still frowned upon by many developers for historical reasons. It’s often cleaner to write out the layouts and content in code. This is the same difference between writing your own HTML and using something like FrontPage or DreamWeaver or Wix to create a page. While those are legitimate applications, they are less “professional”. In the code view, we can see the XML: tags, attributes, values. Tags nested inside one another. The provided XML code defines a layout, and inside that is a TextView (a View representing some text), which has a value: text! We can change that and then re-run the app to see it update! It’s also possible to define this value in values/strings (e.g., as a constant), then refer to as @string/message. More on this proces later. Finally, as a fun demonstration, try to set an icon for the App (in Android Studio, go to: File &gt; New &gt; Image Asset) "],
["activities.html", "Lecture 2 Activities and Logging 2.1 Making Activities 2.2 The Activity Lifecycle 2.3 Logging &amp; ADB 2.4 Basic Events 2.5 Multiple Activities 2.6 Back &amp; Tasks", " Lecture 2 Activities and Logging This lecture introduces Activities, which are the basic component used in Android applications. It aims to demonstrate how the interactive patterns used in other graphical applications are utilized in Android. This lecture references code found at https://github.com/info448-s17/lecture02-activities, in the android/ folder. As a first step, you’ll need to create a new Android application with a single Empty Activity (e.g., MainActivity). Future chapters will have starter code to work from, but it is good practice to make a new application from scratch! According to Google: An Activity is an application component that provides a screen with which users can interact in order to do something. You can think of an Activity as a single screen in your app, the equivalent of a “window” in a GUI system (or a JFrame in a Swing app). Note that Activities don’t need to be full screens: they can also be floating modal windows, embedded inside other Activities (like half a screen), etc. But we’ll begin by thinking of them as full screens. We can have lots of Activities (screens) in an application, and they are loosely connected so we can easily move between them. In many ways, an Activity is a “bookkeeping mechanism”: a place to hold state and data, and tell to Android what to show on the display. It functions much like a Controller (in Model-View-Controller sense) in that regard! Also to note from the documentation1: An activity is a single, focused thing that the user can do. which implies a design suggestion: Activities (screens) break up your App into “tasks”. Each Activity can represent what a user is doing at one time. If the user does something else, that should be a different Activity (and so probably a different screen). 2.1 Making Activities We create our own activities by subclassing (extending) the framework’s Activity class. We use inheritance to make a specialized type of Activity (similar to extending JFrame in Swing apps). By extending this class we inherit all of the methods that are needed to control how the Android OS interacts with the Activity. If you look at the default Empty MainActivity, it actually subclasses AppCompatActivity, which is a already specialized kind of Activity that provides an ActionBar (the toolbar at the top of the screen with the name of you app). If you change the class to just extend Activity, that bar disappears. To make this change, you will need to import the Activity class! The keyboard shortcut in Android Studio is alt+return, or you can do it by hand (look up the package)! You can also set Android Studio to automatically import classes you use. There are a number of other built-in Activity subclasses that we could subclass instead. We’ll mention them as they become relevant. Many on the books have been deprecated in favor of Fragments, which are sort of like “sub-activities” that get nested in larger Activities. We’ll talk about Fragments more in a letter lecture. Other important point to note: does this activity have a constructor that we call? No! We never write code that instantiates our Activity (we never call new MainActivity()). There is no main method in Android. Activities are created and managed by the Android operating system when the app is launched. 2.2 The Activity Lifecycle Although we never call a constructor or main, Activities do have an incredibly well-defined lifecycle—that is, a series of events that occur during usage (e.g., when the Activity is created, when it is stopped, etc). When each of these events occur, Android executes a callback method, similar to how you call actionPerformed() to react to a “button press” event in Swing. We can override these methods in order to do special actions (read: run our own code) when these events occur. What is the lifecycle? Lifecycle state diagram, from Google2. See also an alternative, simplified diagram here. There are 7 “events” that occur in the Activity Lifecycle, which are designated by the callback function that they execute: onCreate(): called when the Activity is first created/instantiated. This is where you initialize the UI (e.g., specify the layout to use), similar to what might go in a constructor. onStart(): called just before the Activity becomes visible to the user. The difference between onStart() and onCreate() is that onStart() can be called more than once (e.g., if you leave the Activity, thereby hiding it, and come back later to make it visible again). onResume(): called just before user interaction starts, indicating that the Activity is ready to be used! This is a little bit like when that Activity “has focus”. While onStart() is called when the Activity becomes visible, onResume() is called when then it is ready for interaction. It is possible for an Activity to be visible but not interactive, such as if there is a modal pop-up in front of it (partially hiding it). onPause(): called when the system is about to start another Activity (so about to lose focus). This is the “mirror” of onResume(). When paused, the activity stays visible! This callback is usually used to quickly and temporarily store unsaved changes (like saving an email draft in memory) or stop animations or video playback. The Activity may be being left (on its way out), but could just be losing focus. onStop(): called when the activity is no longer visible. (e.g., another Activity took over, but this also be because the Activity has been destroyed. This callback is a mirror of onStart(). This callback is where you should persist any state information (e.g., saving the user’s document or game state). It is intended to do more complex “saving” work than onPause(). onRestart(): called when the Activity is coming back from a “stopped” state. This event allows you to run distinct code when the App is being “restarted”, rather than created for the first time. It is the least commonly used callback. onDestroy(): called when the Activity is about to be closed. This can happen because the user ended the application, or (and this is important!) because the OS is trying to save memory and so kills the App. Android apps run on devices with significant hardware constraints in terms of both memory and battery life. Thus the Android OS is very aggressive about not leaving Apps running “in the background”. If it determines that an App is no longer necessary (such as because it has been hidden for a while), that App will be destroyed. Note that this destruction is unpredictable, as the “necessity” of an App being open is dependent on the OS’s resource allocation rules. The onDestroy() callback can do final app cleanup, but its better to have such functionality in onPause() or onStop(). Note that apps may not need to use all of these callbacks! For example, if there is no difference between starting from scratch and resuming from stop, then you don’t need an onRestart() (since onStart() goes in the middle). Similarly, onStart() may not be needed if you just use onCreate() and onResume(). But these lifecycles allow for more granularity and the ability to avoid duplicate code. 2.2.1 Overriding the Callback Methods In the default MainActivity the onCreate() callback has already been overridden for us, since that’s where the layout is specified. Notice that this callback takes a Bundle as a parameter. A Bundle is an object that stores key-value pairs, like a super-simple HashMap (or an Object in JavaScript, or dictionary in Python). Bundles can only hold basic types (numbers, Strings) and so are used for temporarily “bunding” small amounts of information. This Bundle parameter in particular stores information about the Activity’s current state (e.g., what text they may have typed into a search box), so that if the App gets killed it can be restarted in the same state and the user won’t notice that it was ever lost! The Bundle stores current layout information in it by default (if the Views have ids)—technically, it calls a onSaveInstanceState() callback for each View in the layout, and the provided Views that we utilize tend to save important state information (like entered text) already. See Saving and restoring activity state for details. Also note that we call super.onCreate(). Always call up the inheritance chain!. This allows the system-level behavior to continue without any problem. We can also add other callbacks: for example, onStart() (see the documentation for examples). But how can we know if the lifecycle events are getting called? 2.3 Logging &amp; ADB In Android, we can’t use System.out.println() because we don’t actually have a terminal to print to! More specifically, the device (which is where the application is running) doesn’t have access to standard out (stdout), which is what Java means by System.out. It is possible to get access to stdout with adb using adb shell stop; adb shell setprop log.redirect-stdio true; adb shell start, but this is definitely not ideal. Instead, Android provides a Logging system that we can use to write out debugging information, and which is automatically accessible over the adb (Android Debugging Bridge). Logged messages can be filtered, categorized, sorted, etc. Logging can also be disabled in production builds for performance reasons (though it often isn’t). To perform this logging, we’ll use the android.util.Log3 class. This class includes a number of static methods, which all basically wrap around println to print to the device’s log file, which is then accessible through the adb. Remember to import the Log class! The device’s log file is stored persistantly… sort of. It’s a 16k file, but it is shared across the entire system. Since every single app and piece of the system writes to it, it fills up fast. Hence filtering/searching becomes important, and you tend to watch the log (and debug your app) in real time! 2.3.1 Log Methods Log provides methods that correspond to different level of priority (importance) of the messages being recorded. From low to high priority: Log.v(): VERBOSE output. This is the most detailed, for everyday messages. This is often the go-to, default level for logging. Ideally, Log.v() calls should only be compiled into an application during development, and removed for production versions. Log.d(): DEBUG output. This is intended for lower-level, less detailed messages (but still code-level, that is referring to specific programming messages). These messages can be compiled into the code but are removed at runtime in production builds through Gradle. Log.i(): INFO output. This is intended for “high-level” information, such at the user level (rather than specifics about code) Log.w(): WARN output. For warnings Log.e(): ERROR output. For errors Also if you look at the API… Log.wtf()! These different levels are used to help “filter out the noise”. So you can look just at errors, at errors and warnings, at error, warn, and info… all the way down to seeing everything with verbose. A huge amount of information is logged, so filtering really helps! Each Log method takes two Strings as parameters. The second is the message to print. The first is a “tag”—a String that’s prepended to the output which you can search and filter on. This tag is usually the App or Class name (e.g., “AndroidDemo”, “MainActivity”). A common practice is to declare a TAG constant you can use throughout the class: private static final String TAG = &quot;MainActivity&quot;; 2.3.2 Logcat You can view the logs via adb (the debugging bridge) and a service called Logcat (from “log” and “conCATenation”, since it concats the logs). The easiest way to check Logcat is to use Android Studio. The Logcat browser panel is usually found at the bottom of the screen after you launch an application. It “tails” the log, showing the latest output as it appears. You can use the dropdown box to filter by priority, and the search box to search (e.g., by tag if you want). Android Studio also lets you filter to only show the current application, which is hugely awesome. Note that you may see a lot of Logs that you didn’t produce, including possibly Warnings (e.g., I see a lot of stuff about how OpenGL connects to the graphics card). This is normal! It is also possible to view Logcat through the command-line using adb, and includes complex filtering arguments. See Logcat Command-line Tool for more details. Demo: And now we can finally log out some of the Lifecycle callbacks to see them being executed! Start by implementing onResume(). Note the wonders of tab completion! Have it log out at INFO level. On the device, hit the main menu (circle) button to send the Activity to the background, and watch the callback be executed. Implement onStop() and switch out of the app to watch it be stopped. onDestroy() can easily be called if you set the phone to “Don’t Keep Activities” (at bottom of developer settings). Or you can simply rotate the phone (which causes the Activity to be destroyed and then recreated in the new orientation). Something else to test: Cause the app to throw a runtime Exception in one of the handlers. For example, you could make a new local array and try to access an item out of bounds. Or just throw new RuntimeException() (which is slightly less interesting). Can you see the Stack Trace in the logs? Logging is fantastic and one of the the best techniques we have for debugging, both in how Activities are being used or for any kind of bug (also RuntimeExceptions). It harkens back to printline debugging, which is still a legitimate debugging process. Note that Android Studio does have a built-in debugger if you’re comfortable with such systems. 2.4 Basic Events Once you can “output” some content (via Log), the next step is to add some “input” via an interface element: for example, a Button we can click. In res/layouts/activity_main.xml (the Activity’s layout), add the following code inside the &lt;android.support.constraint.ConstraintLayout&gt; element, replacing the current &lt;TextView&gt; element. &lt;Button android:id=&quot;@+id/my_button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Start Activity&quot; /&gt; This XML defines a Button. The android:text attribute specifies the text that is on the button. The next lecture will describe in more detail how exactly this XML works (and what’s is meant by the id, and layout_width/height), but you should be able to make a pretty good educated guess based on the names. Defining this in XML is basically the same process as creating the JButton and adding it to the JFrame in Java! Now we have a button, but we want to be able to click on it. So we need to register a “listener” for it (in Java), just like with Swing apps: Button button = (Button)findViewById(R.id.my_button); button.setOnClickListener(new View.OnClickListener() { public void onClick(View v) { // Perform action on click } }); First we need to get access to a variable that represents that Button we defined in the XML. The findViewById() method “finds” the appropriate XML element with the given id. We discuss why we wrote the parameter as R.id.my_button in the next lecture tomorrow. Note that this method returns a View, so we want to cast the value into the more specific Button (which has methods we want to use). We can register a listener with that button through the .setOnClickListener() method, passing in an anonymous class to act as the listener. (Again, tab-completion is our friend!). This is just like what you would do with a Swing app. Finally, we can fill in the method to have it log out something when clicked. Overall, this button is an example of an Input Control. These will be discussed in more detail in Lecture 4. 2.5 Multiple Activities The whole point of interfacing with the Activity Lifecycle is handle the fact that Android applications can have multiple activities and interact with multiple other applications. In this section we’ll briefly discuss how to include multiple Activities within an app (in order to sense how the life cycle may affect them). Note that working with multiple Activities will be discussed in more detail in a later lecture. We can easily create a New Activity through Android Studio by using File &gt; New &gt; Activity. We could also just add a new .java file with the Activity class in it, but using Android Studio will also provide the onCreate() method stub as well as a layout resource. For practice, make a new Empty Activity called SecondActivity. You shuld edit this Activity’s layout resource so that the &lt;TextView&gt; displays an appropriate message. Importantly, for every Activity we make, an entry gets added to the Manifest file AndroidManifest.xml. This file acts like the “table of contents” for our application, telling the device Operating System information about what our app looks (that is, what Activities it has) like so that the OS can open appropriate Activities as needed. Activities are listed as &lt;activity&gt; elements nested in the &lt;application&gt; element. If you inspect the file you will be able to see an element representing the first MainActivity; that entry’s child elements will be discussed later. We can add android:label attributes to these &lt;activity&gt; elements in order to give the Activities nicer display names (e.g., in the ActionBar). 2.5.1 Intents and Context In Android, we don’t start new Activities by instantiating them (remember, we never instantiate Activities!). Instead, we send the operating system a message requesting that the Activity perform a particular action (i.e., start up and display on the screen). These messages are called Intents, and are used to communicate between app components like Activities. The Intent system allows Activities to communicate, even though they don’t have references to each other (we can’t just call a method on them). I don’t have a good justification for the name, other than Intents announce an “intention” for the OS to do something (like start an Activity) You can think of Intents as like envelopes: they are addressed to a particular target (e.g., another Activity—or more properly a Context), and contain a brief message about what to do. An Intent is an object we can instantiate: for example, we can create a new Intent in the event handler for when we click the button on MainActivity. The Intent class has a number of different cnstructors, but the one we’ll start with looks like: Intent intent = new Intent(MainActivity.this, SecondActivity.class); The second parameter to this constructor is the class we want to send the Intent to (the .class property fetches a reference to the class type; this is metaprogramming!). Effectively, it is the “address” on the envelop for the message we’re sending. The first parameter refers to the current Context4 in which the message should be delivered. Context is an abstract class (and a superclass of Activity) that acts as a reference for information about the current running environment: it represents environmental data (information like “What OS is running? Is there a keyboard plugged in?”). You can almost think of the Context as representing the “Application”, though it’s broader than that (Application is actually a subclass of Context!) The Context is used to do “application-level” actions: mostly working with resources (accessing and loading them), but also communicating between Activities like we’re doing now. Effectively, it lets us refer to the state in which we are running: the “context” for our code (e.g., “where is this occurring?”). It’s a kind of reflection or meta-programming, in a way. There are a couple of different kinds of Contexts we might wish to refer to: The Application context (e.g., an Application object) references the state of the entire application. It’s basically the Java object that is built out of the &lt;application&gt; element in the Manifest (and so contains that level of information). The Activity context (e.g., an Activity object) that references the state of that Activity. Again, this roughly corresponds to the Java objects created out of the &lt;activity&gt; tags from the Manifest. Each of these Context objects exist for the life of its respective component: that is, an Activity Context is available as long as the Activity exists (disappearing after onDestroy()), whereas Application Contexts survive as long as the application does. Note htat we’ll almost always use the Activity context, as it’s safer and less likely to cause memory leaks. Inside an Activity object (e.g., in a lifecycle callback function), you can refer to the current Activity using this. And since Activity is a Context, you can also use this to refer to the current Activity context. You’ll often see Context methods called as undecorated methods (without an explicit this). After having instantiated the new Intent, we can use that message to start an Activity by calling the startActivity() method (inherited from Activity), passing it the Intent: startActivity(intent); This method will “send” the message to the operating system, which will deliver the Intent to the appropriate Activity, telling that Activity to start as soon as it receives the message. With this interaction in place, we can now click a button to start a second activity, and see how that impacts our Lifecycle callbacks. And we can use the back button to go backwards! There are actually a couple of different kinds of Intents (this is an Explicit Intent, because it is explicit about what Activity it’s sent to), and a lot more we can do with them. We’ll dive into Intents in more detail later; for now we’re going to focus on mostly Single Activities. For example, if you look back at the Manifest, you can see that the MainActivity has an &lt;intent-filter&gt; child element that allows it to receive particular kinds of Intents—including ones for when an App is launched for the first time! 2.6 Back &amp; Tasks We’ve shown that we can have lots of Activities (and of course many more can exist cross multiple apps), and we are able to move between them by sending Intents and clicking the “Back” button. But how exactly is that “Back” button able to keep track of where to go to? The abstract data type normally associated with “back” or “undo” functionality is a stack, and that is exactly what Android uses. Every time you start a new Activity, Android instantiates that object and puts it on the top of a stack. Then when you hit the back button, that activity is “popped” off the stack and you’re taken to the Activity that is now at the top. An example of the Activity stack, from Google5. However, you might have different “sequences” of actions you’re working on: maybe you start writing an email, and then go to check your Twitter feed through a different set of Activities. Android breaks up these sequences into groups called Tasks. A Task is a collection of Activities arranged in a Stack, and there can be multiple Tasks in the background of your device. Tasks usually start from the Android “Home Screen”—when you launch an application, that then starts a new Task. Starting new Activities from that application will add them to the Stack of the task. If you go back to the Home Screen, the Task you’re currently on is moved to the background, so the “back” button won’t let you navigate that Stack. It’s useful to think of Tasks as being like different tabs or browsers, with the “back stack” being the history of web pages visited wthin that tab. As a demonstration, try switching to another (built-in) app and then back to the example app; how does the back button work in each situation? An important caveat: Tasks are distinct from one another, so you can have different copies of the same Activity on multiple stacks (e.g., the Camera activity could be part of both Facebook and Twitter app Tasks if you are on a selfie binge). It is possible to modify this behavior though, see - Though it is possible to modify this, see Managing Tasks 2.6.1 Up Navigation We can make this “back” navigation a little more intuitive for users by providing explicit up navigation, rather than just forcing users to go back through Activities in the order they viewed them (e.g., if you’re swiping through emails and want to go back to the home list). To do this, we just need to add a little bit of configuration to our Activities: In the Java code, we want to add more functionality to the ActionBar. Think: which lifecycle callback should this specification be put in? //specify that the ActionBar should have an &quot;home&quot; button getSupportActionBar().setHomeButtonEnabled(true); Then in the Manifest, add an android:parentActivityName attribute to the SecondActivity, with a value set to the full class name (including package and appname!) of your MainActivity. This will let you be able to use the “back” visual elements (e.g., of the ActionBar) to move back to the “parent” activity. See Up Navigation for details. &lt;activity android:name=&quot;.SecondActivity&quot; android:label=&quot;Second Activity&quot; android:parentActivityName=&quot;edu.uw.activitydemo.MainActivity&quot;&gt; &lt;meta-data android:name=&quot;android.support.PARENT_ACTIVITY&quot; android:value=&quot;edu.uw.activitydemo.MainActivity&quot; /&gt; &lt;/activity&gt; The &lt;meta-data&gt; element is to provide backwards compatibilit for API level 15 (since the android:parentActivityName is only defined for API level 16+). https://developer.android.com/reference/android/app/Activity.html↩ http://developer.android.com/images/activity_lifecycle.png↩ http://developer.android.com/reference/android/util/Log.html↩ https://developer.android.com/reference/android/content/Context.html↩ http://developer.android.com/images/fundamentals/diagram_backstack.png↩ "],
["resources-and-layouts.html", "Lecture 3 Resources and Layouts 3.1 Resources 3.2 Views 3.3 Layouts", " Lecture 3 Resources and Layouts This lecture discusses Resources, which are used to represent elements or data that are separate from the behavior (functional logic) of the app. In particular, this lecture focuses on how resources are used to define Layouts for user interfaces. While the Activities lecture focused on the Java portion of Android apps; this lecture focuses on the XML. This lecture references code found at https://github.com/info448-s17/lecture03-layouts. 3.1 Resources Resources can be found in the res/ folder, and represent elements or data that are “external” to the code. You can think of them as “media content”: often images, but also things like text clippings (or short String constants). Textual resources are usually defined in XML files. This is because resources represent elements (e.g., content) that is separate from the code (the behavior of the app), so is kept separate from the Java code to support the Principle of Separation of Concerns By defining resources in XML, they can be developed (worked on) without coding tools (e.g., with systems like the graphical “layout design” tab). Theoretically you could have a Graphic Designer create these resources, which can then be integrated into the code without the designer needing to do a lick of Java. Similarly, keeping resources separate allows you to choose what resources to include dynamically. You can choose to show different images based on device screen resolution, or pick different Strings based on the language of the device (internationalization!)—the behavior of the app is the same, but the “content” is different! This is similar to how in web development we may want to have the same JavaScript from different HTML. What should be a resource? In general: Layouts should always be resources UI controls (buttons, etc) should mostly be defined as resources (part of layouts), though behavior will be defined programmtically (in Java) Any graphic images (drawables) should be resources Any user-facing strings should be resources Style and theming information should be resources As introduced in Lecture 1, there are a number of different resource types used in Android, many of which can be found in the res/ folder of a default Android project, including: res/drawable/: contains graphics (PNG, JPEG, etc) res/layout/: contains UI XML layout files res/mipmap/: conatins launcher icon files in different resolutions res/values/: contains XML definitions for general constants /strings: short string constants (e.g., labels) /colors: color constants /styles : constants for style and theme details /dimen : dimensional constants (like default margins); not created by default in Android Studio 2.3+. The details about these different kinds of resources is a bit scattered throughout the documentation, but Resource Types6 is a good place to start, as is Providing Resources. 3.1.1 Alternate Resources These aren’t the only names for resource folders: as mentioned above, part of the goal of resources is that they can be localized: changed depending on the device! You are thus able to specify folders for “alternative” resources (e.g., special handling for another language, or for low-resolution devices). At runtime, Android will check the configuration of the device, and try to find an alternative resource that matches that config. If it it can’t find a relevant alternative resource, it will fall back to the “default” resource. There are many different configurations that can be used to influence resources; see Providing Resources7. To highlight a few options, you can specify different resources based on: Language and region (e.g., via two-letter ISO codes) Screen size(small, normal, medium, large, xlarge) Screen orientation (port for portrait, land for landscape) Specifc screen pixel density (dpi) (ldpi, mdpi, hdpi, xhdpi, xxhdpi, etc.). xxhdpi is pretty common for high-end devices. Note that dpi is “dots per inch”, so these values represent the number of pixels across relative to the device size! Platform version (v1, v4, v7… for each API number) Configurations are indicated using the directory name, giving them the form &lt;resource_name&gt;(-&lt;config_qualifier&gt;)+ You can see this in action by using the New Resource wizard (File &gt; New &gt; Android resource file) to create a welcome message (a string resource, such as for the app_name) in another language8, and then changing the device’s language settings to see the content automatically adjust! &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;Mon Application&lt;/string&gt; &lt;/resources&gt; Switch to the Package view in Android Studio to see how the folder structure for this works. 3.1.2 XML Details Resources are usually defined as XML (which is similar in syntax to HTML). The strings.xml example used above involves fairly simple elements but more complexresource is pretty simple, but more complex details can be seen in the activity_main.xml resource inside layout/. Android-specific attributes are namespaced with a android: prefix, to avoid any potential conflicts (e.g., so we know we’re talking about Android’s text instead of something else). We can use the @ symbol to reference one resource from another, following the schema @[&lt;package_name&gt;:]&lt;resource_type&gt;/&lt;resource_name&gt; We can also use the + symbol to create a new resource that we can refer to; this is a bit like declaring a variable inside an attribute. This is most commonly used with the android:id attribute (android:id=&quot;@+id/identifier&quot;), see below for details. 3.1.3 R Although XML resources are defined separately from the Java code, resources can be accessed from within Java. When an application is compiled, the build tools (e.g., gradle) generate an additional Java class called R (for “resource”). This class contains what is basically a giant list of static “constants”—one for each resource! These constants are organized into subclasses, one for each resource type. This allows you to refer to a specific resource in the Java code as [(package_name).]R.resource_type.identifier similar to the kind of syntax used to refer to a nested JSON object! For example: R.string.hello (the hello string resource), R.drawable.icon or R.layout.activity_main For most resources, the identifier is defined as an element attribute (id for specific View elements in layouts, name attribute for values). For more complex resources such as entire layouts or drawables, the identifier is the filename (without the XML); hence R.layout.activity_main refers to the root element of the layout/activity_main.xml file. Note that that @ symbol used in the XML goes to the R Java file to look things up, so follows the same reference syntax. You can find the generated R.java file inside app/build/generated/source/r/debug/... (Use the Project Files view in Android Studio). The static constants inside the R.java file are often just ints that are pointers to element references (similar to passing a pointer* around in the C language). So in the Java, we usually work with int as the data type for XML resources, because we’re actually working with pointers to those resources. You can think of each int constant as a “key” or “index” for that resource (in the list of all resources). Android does the hard work of taking that int, looking it up in an internal resource table, finding the associated XML file, and then getting the right element out of that XML. (By hard work, I mean in terms of implementation. Android is looking up these references directly in memory, so the look-up is a fast O(1)). Because the R class is included in the Java, we can access these constants directly in our code (as R.resource_type.identifier). For example, the setContentView() call in an Activity’s onCreate() takes in a resource int. The other comment method that utilizes resources will be findViewById(int), which is used to reference a View element (e.g., a button) from the resource in order to call methods on it in Java. This is the same method used with the Button example in the Activities lecture The R class is regenerated all time (any time you change a resource, which is often); when Eclipse was the recommend Android IDE, you often needed to manually regenerate the class so that the IDE’s index would stay up to date! You can perform a similar task in Android Studio by using Build &gt; Clean Project and Build &gt; Rebuild Project. 3.2 Views The most common type of element we’ll define in resources are Views9. View is the superclass for visual interface elements—a visual component on the screen is a View. Specific types of Views include: TextViews, ImageViews, Buttons, etc. View is a superclass for these components because it allows us to use polymorphism to treat all these visual elements the same way as instances of the same type. We can lay them out, draw them, click on them, move them, etc. And all the behavior will be the same—though subclasses can also have “extra” features Here’s the big trick: one subclass of View is ViewGroup10. A ViewGroup can contain other “child” Views. But since ViewGroup is a View… it can contain more ViewGroups inside it! Thus we can nest Views within Views, following the Composite Pattern. This ends up working a lot like HTML (which can have DOM elements like &lt;div&gt; inside other DOM elements), allowing for complex user interfaces. Thus Views are structured into a tree, what is known as the View hierarchy. Views are defined inside of Layouts—that is, inside a layout resource, which is an XML file describing Views. These resources are “inflated” (rendered) into UI objects that are part of the application. Technically, Layouts are simply ViewGroups that provide “ordering” and “positioning” information for the Views inside of them. they let the system “lay out” the Views intelligently and effectively. Individual views shouldn’t know their own position; this follows from good good object-oriented design and keeps the Views encapsulated. Android studio does come with a graphical Layout Editor (the “Design” tab) that can be used to create layouts. However, most developers stick with writing layouts in XML. This is mostly because early design tools were pathetic and unusable, so XML was all we had. Although Android Studio’s graphical editor can be effective, for this course you should create layouts “by hand” in XML. This is helpful for making sure you understand the pieces underlying development, and is a skill you should be comfortable with anyway (similar to how we encourage people to use git from the command-line). 3.2.1 View Properties Before we get into how to group Views, let’s focus on the individual, basic View classes. As an example, consider the activity_main layout in the lecture code. This layout contains two individual View elements (inside a Layout): a TextView and a Button. All View have properties which define the state of the View. Properties are usually defined within the resource XML as element attributes. Some examples of these property attributes are described below. android:id specifies a unique identifier for the View. This identifier needs to be unique within the layout, though ideally is unique within the entire app (for clarity). Identifiers must be legal Java variable names (because they are turned into a variable name in the R class), and by convention are named in lower_case format. Style tip: it is useful to prefix each View’s id with its type (e.g., btn, txt, edt). This helps with making the code self-documenting. You should give each interactive View a unique id, which will allow its state to automatically be saved as a Bundle when the Activity is destroyed. See here for details. android:layout_width and android:layout_height are used to specify the View’s size on the screen (see ViewGroup.LayoutParams for documentation). These values can be a specific value (e.g., 12dp), but more commonly is one of two special values: wrap_content, meaning the dimension should be as large as the content requires, plus padding. match_parent, meaning the dimension should be as large as the parent (container) element, minus padding. This value was renamed from fill_parent (which has now been deprecated). Android utilizes the following dimensions or units: dp is a “density-independent pixel”. On a 160-dpi (dots-per-inch) screen, 1dp equals 1px (pixel). But as dpi increases, the number of pixels per dp increases. These values should be used instead of px, as it allows dimensions to work independent of the hardware’s dpi (which is highly variable). px is an actual screen pixel. DO NOT USE THIS (use dp instead!) sp is a “scale-independent pixel”. This value is like dp, but is scale by the system’s font preference (e.g., if the user has selected that the device should display in a larger font, 1sp will cover more dp). You should always use sp for text dimensions, in order to support user preferences and accessibility. pt is 1/72 of an inch of the physical screen. Similar units mm and in are available. Not recommended for use. android:padding, android:paddingLeft, android:margin, android:marginLeft, etc. are used to specify the margin and padding for Views. These work basically the same way they do in CSS: padding is the space between the content and the “edge” of the View, and margin is the space between Views. Note that unlike CSS, margins between elements do not collapse. android:textSize specifies the “font size” of textual Views (use sp units!), android:textColor specifies the color of text (reference a color resource!), etc. There are lots of other properties as well! You can see a listing of generic properties in the View11 documentation, look at the options in the “Design” tab of Android Studio, or browse the auto-complete options in the IDE. Each different View class (e.g., TextView, ImageView, etc.) will also have their own set of properties. Note that unlike CSS, styling properties specified in the layout XML resources are not inherited; we’re effectively specifying an inline style attribute for that element, and one that won’t affect child elements. In order to define shared style properies, you’ll need to use styles resources, which are discussed in a later lecture. While it is possible to specify these visual properties dynamically via Java methods (e.g., setText(), setPadding()). You should only use Java methods to specify View properties when they need to be dynamic (e.g., the text changes in response to a button click)—it is much cleaner and effective to specify as much visual detail in the XML resource files as possible. It’s also possible to simply replace one layout resource with another (see below). Views also have inspection methods such as isVisible() and hasFocus(); we will point to those as we need them. Do not define Views or View appearances in an Activity’s onCreate() callback, unless the properties (e.g., content) truly cannot be determined before runtime! Specify layouts in the XML instead. 3.2.2 Practice Add a new ImageView element that contains a picture. Be sure and specify its id and size (experiment with different options). You can specify the content of the image in the XML resource using the android:src attribute (use @ to reference a drawable), or you can specify the content dynamically in Java code: ImageView imageView = (ImageView)findViewById(R.id.img_view); imageView.setImageResource(R.drawable.my_image); 3.3 Layouts As mentioned above, a Layout is a grouping of Views (specifically, a ViewGroup). A Layout acts as a container for other Views, to help organize things. Layouts are all subclasses of ViewGroup, so you can use its inheritance documentation to see a (mostly) complete list of options, though many of the listed classes are deprecated in favor of later, more generic/powerful options. 3.3.1 LinearLayout Probably the simplest Layout to understand is the LinearLayout. This Layout simply orders the children View in a line (“linearly”). All children are laid out in a single direction, but you can specify whether this is horizontal or vertical with the android:orientation property. See LinearLayout.LayoutParams for a list of all attribute options! Remember: since a Layout is a ViewGroup is a View, you can also utilize all the properties discussed above; the attributes are inherited! Another common property you might want to control in a LinearLayout is how much of any remaining space the elements should occupy (e.g., should they expand). This is done with the android:layout_weght property. After all element sizes are calculated (via their individual properties), the remaining space within the Layout is divided up proportionally to the layout_weight of each element (which defaults to 0 so they get no extra space). See the example in the guide for more details. Useful tip: Give elements 0dp width or height and 1 for weight to make everything in the Layout the same size! You can also use the android:layout_gravity property to specify the “alignment” of elements within the Layout (e.g., where they “fall” to). Note that this property is specified on individual child Views. An important point Since Layouts are Views, you can of course nest LinearLayouts inside each other! So you can make “grids” by creating a vertical Layout containing “rows” of horizontal Layouts (which contain Views). As with HTML, there are lots of different options for achieving any particular interface layout. 3.3.2 RelativeLayout A RelativeLayout is more flexible (and hence powerful), but can be more complex to use. In a RelativeLayout, children are positioned “relative” to the parent OR to each other. All children default to the top-left of the Layout, but you can give them properties from RelativeLayout.LayoutParams to specify where they should go instead. For example: android:layout_verticalCenter centers the View vertically within the parent. android:layout_toRightOf places the View to the right of the View with the given resource id (use an @ reference to refer to the View by its id): &lt;TextView android:id=&quot;@+id/first&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;FirstString&quot; /&gt; &lt;TextView android:id=&quot;@+id/second&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@id/first&quot; android:layout_alignParentLeft=&quot;true&quot; android:text=&quot;SecondString&quot; /&gt; (Recall that the @+ syntax defines a new View id, like declaring a variable!) You do not need to specify both toRightOf and toLeftOf; think about placing one element on the screen, then putting another element relative to what came before. This can be tricky. For this reason the author prefers to use LinearLayouts, since you can always produce a Relative positioning using enough LinearLayouts (and most layouts end up being linear in some fashion anyway!) 3.3.3 ConstraintLayout ConstraintLayout is a Layout provided as part of an extra support library, and is what is used by Android Studio’s “Design” tool (and thus is the default Layout for new layout resources). ConstraintLayout works in a manner conceptually similar to RelativeLayout, in that you specify the location of Views in relationship to one another. However, ConstraintLayout offers a more powerful set of relationships in the form of constraints, which can be used to create highly responsive layouts. See the class documentation for more details and examples of constraints you can add. The main advantage of ConstraintLayout is that it supports development through Android Studio’s Design tool. However, since this course is focusing on implementing the resource XML files rather than using the specific tool (that may change in a year’s time), we will primarily be using other layouts. 3.3.4 Other Layouts There are many other layouts as well, though we won’t go over them all in depth. They all work in similar ways; check the individual class’s documentatoion for details. FrameLayout is a sort of “placeholder” layout that holds a single child View (a second child will not be shown). You can think of this layout as a way of adding a simple container to use for padding, etc. It is also highly useful for situations where the framework requires you to specify a Layout resource instead of just an individual View. GridLayout arranges Views into a Grid. It is similar to LinearLayout, but places elements into a grid rather than into a line. Note that this is different than a Grid_View_, which is a scrollable, adaptable list (similar to a ListView, which is discussed in the next lecture). TableLayout acts like an HTML table: you define TableRow layouts which can be filled with content. This View is not commonly used. 3.3.5 Combining and Inflating Layouts It is possible to combine multiple layout resources. This is useful if you want to dynamically change what Views are included, or to refactor parts of a layout into different XML files to improve code organization. As one option, you can statically include XML layouts inside other layouts by using an &lt;include&gt; element: &lt;include layout=&quot;@layout/sub_layout&quot;&gt; But it is also possible to dynamically load views “manually” (e.g., in Java code) using the LayoutInflator. This is a class that has the job of “inflating” (rendering) Views. The process is called “inflating” based on the idea that it is “unpacking” or “expanding” a compact resource description into a complex Java Object. LayoutInflator is implicitly used in the setContentView() method, but can also be used independently with the following syntax: LayoutInflator inflator = getLayoutInflator(); //access the inflator (called on the Activity) View myLayout = inflator.inflate(R.layout.my_layout, parentViewGroup, true); //to attach Note that we never instantiate the LayoutInflator, we just access an object that is defined as part of the Activity. The inflate() method takes a couple of arguments: The first parameter is a reference to the resource to inflate (an int saved in R) The second parameter is a ViewGroup to act as the “parent” for this View—e.g., what layout should the View be inflate inside? This can be null if there is not yet a layout context; e.g., you wish to inflate the View but not show it on the screen yet. The third (optional) parameter is whether to actually attach the inflated View to that parent (if not, the parent just provides context and layout params to use). If not assigning to parent on inflation, you can later attach the View using methods in ViewGroup (e.g., addView(View) similar to what we’ve done with Swing). Manually inflating a View works for dynamically loading resources, and we will often see UI implementation patterns that utilize Inflators. However, for dynamic View creation it tends to be messy and hard to maintain (UI work should be specified entirely in the XML, without needing multiple references to parent and child Views) so it isn’t as common in modern development. A much cleaner solution is to use a ViewStub12. A ViewStub is like an “on deck” Layout: it is written into the XML, but isn’t actually shown until you choose to reveal it via Java code. With a ViewStub, Android inflates the View at runtime, but then removes it from the parent (leaving a “stub” in its place). When you call inflate() (or setVisible(View.VISIBLE)) on that stub, it is reattached to the View tree and displayed: &lt;!-- XML --&gt; &lt;ViewStub android:id=&quot;@+id/stub&quot; android:inflatedId=&quot;@+id/subTree&quot; android:layout=&quot;@layout/mySubTree&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; //Java ViewStub stub = (ViewStub)findViewById(R.id.stub); View inflated = stub.inflate(); https://developer.android.com/guide/topics/resources/available-resources.html↩ http://developer.android.com/guide/topics/resources/providing-resources.html↩ https://www.webucator.com/blog/2010/03/saying-hello-world-in-your-language-using-javascript/↩ http://developer.android.com/reference/android/view/View.html↩ http://developer.android.com/reference/android/view/ViewGroup.html↩ http://developer.android.com/reference/android/view/View.html#lattrs↩ http://developer.android.com/training/improving-layouts/loading-ondemand.html↩ "],
["interactive-views.html", "Lecture 4 Interactive Views 4.1 Inputs 4.2 ListViews and Adapters 4.3 Network Data", " Lecture 4 Interactive Views This lecture discusses how to use Views to support user interaction and dynamic content, building on the previous lecture as while drawing on concepts introduced in the Threads and HTTP Requests Appendix. This lecture references code found at https://github.com/info448-s17/lecture04-inputs-lists. 4.1 Inputs The previous lecture discussed Views and ViewGroups (Layouts), and introduced some basic Views such as TextView, ImageView, and Button. A Button is an example of an Input Control. These are simple (single-purpose; not necessarily lacking complexity) widgets that allow for user input. There are many such widgets in addition to Button, mostly found in the android.widget package. Many correspond to HTML &lt;input&gt; elements, but Android provided additional widgets at well. Launch the lecture code’s MainActivity with a content View of R.id.input_control_layout to see an example of many widgets (as well as a demonstration of a more complex layout!). These widgets include: Button, a widget that affords clicking. Buttons can display text, images or both. EditText, a widget for user text entry. Note that you can use the android:inputType property to specify the type of the input similar to an HTML &lt;input&gt;. Checkbox, a widget for selecting an on-off state RadioButton, a widget for selecting from a set of choices. Put RadioButton elements inside a RadioGroup element to make the buttons mutually exclusive. ToggleButton, another widget for selecting an on-off state. Switch, yet another widget for selecting an on-off state. This is just a ToggleButton with a slider UI. It was introduced in API 14 and is the “modern” way of supporting on-off input. Spinner, a widget for picking from an array of choices, similar to a drop-down menu. Note that you should define the choices as a resource (e.g., in strrings.xml). Pickers: a compound control around some specific input (dates, times, etc). These are typically used in pop-up dialogs, which will be discussed in a future lecture. …and more! See the android.widget package for further options. All these input controls basically work the same way: you define (instantiate) them in the layout resource, then access them in Java in order to define interaction behavior. There are two ways of interacting with controls (and Views in general) from the Java code: Calling methods on the View to manipulate it. This represents “outside to inside” communication (with respect to the View). Listening for events produced by the View and responding to then. This represents “inside to outside” communication (with respect to the View). An example of the second, event-driven approach was introduced in Lecture 2. This involved registering a listener for the event (after acquiring a reference to the View with findViewById()) and then specifying a callback method (by instantiating the Listener interface) that wiould be “called back to” when the event occurs. It is also possible to specify the callback method in the XML resource itself by using e.g., the android:onClick attribute. This value of this attribute should be the name of the callback method: It is also possible to &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;handleButtonClick&quot; /&gt; The callback method is declared in the Java code as taking in a View parameter (which will be a reference to whatever View caused the event to occur) and returning void: public void handleButtonClick(View view) { } We will utilize a mix of both of these strategies (defining callbacks in both the Java and the XML) in this class. Author’s Opinion: It is arguable about which approach is “better”. Specifying the callback method in the Java code helps keep the appearance and behavior separate, and avoids introducing hidden dependencies for resources (the Activity must provide the required callback). However, as buttons are made to be pressed, it isn’t unreasonable to give a “name” in the XML resource as to what the button will do, especially as the corresponding Java method may just be a “launcher” method that calls something else. Specifying the callback in the XML resource may often seem faster and easier, and we will use whichever option best supports clarity of our code. Event callbacks are used to respond to all kind of input control widgets. CheckBoxes use an onClick callback, ToggleButtons use onCheckedChanged, etc. Other common events can be found in the View documentation, and are handled via listeners such as OnDragListener (for drags), OnHoverListener (for “hover” events), OnKeyListener (for when user types), or OnLayoutChangeListener (for when layout changes display). In addition to listening for events, it is possible to call methods directly on referenced Views to access their state. In addition to generic View methods such as isVisible() or hasFocus(), it is possible to inquire directly about the state of the input provided. For example, the isChecked() method returns whether or not a checkbox is ticked. This is also a good way of getting access to inputted content from the Java Code. For example, call getText() on an EditText control in order to fetch the contents of that View. For practice, try to log out the contents of the included EditText control when the Button is pressed! Between listening for events and querying for state, we can fully interact with input controls. Check the official documentation for more details on how to use specific individual widgets. 4.2 ListViews and Adapters The remainder of the lecture utilizes the list_layout Layout in the lecture code. Modify MainActivity so that it uses this resource as its viewContent. Having covered basic controls, this section will now look at some more advanced interactive Views. In particular, it will discuss how to utilize a ListView13, which is a ViewGroup that displays a scrollable list of items! A ListView is basically a LinearLayout inside of a ScrollView (which is a ViewGroup that can be scrolled). Each element within the LinearLayout is another View (usually a Layout) representing a particular item in a list. But the ListView does extra work beyond just nesting Views: it keeps track of what items are already displayed on the screen, inflating only the visible items (plus a few extra on the top and bottom as buffers). Then as the user scrolls, the ListView takes the disappearing views and recycles them (altering their content, but not reinflating from scratch) in order to reuse them for the new items that appear. This lets it save memory, provide better performance, and overall work more smoothly. See this tutorial for diagrams and further explanation of this recycling behavior. Note that a more advanced and flexible version of this behavior is offered by the RecyclerView. See also this guide for more details. The ListView control uses a Model-View-Controller (MVC) architecture. This is a deisgn pattern common to UI systems which organizes programs into three parts: The Model, which is the data or information in the system The View, which is the display or representation of that data The Controller, which acts as an intermediary between the Model and View and hooks them together. The MVC pattern can be found all over Android. At a high level, the resources provide models and views (separately), while the Java Activities act as controllers. Fun fact: The Model-View-Controller pattern was originally developed as part of the Smalltalk language, which was the first Object-Oriented language! Thus in order to utilize a ListView, we’ll have some data to be displayed (the model), the views (Layouts) to be shown, and the ListView itself will connect these together act as the controller. Specifically, the ListView is a subclass of AdapterView, which is a View backed by a data source—the AdapterView exists to hook the View and the data together (a controller!) There are other AdapterViews as well. For example, GridView works exactly the same way as a ListView, but lays out items in a scrollable grid rather than a scrollable list. In order to use a ListView, we need to get the pieces in place: First we specify the model: some raw data. We will start with a simple String[], filling it with placeholder data: String[] data = new String[99]; for(int i=99; i&gt;0; i--){ data[99-i] = i+ &quot; bottles of beer on the wall&quot;; } While we could define this data as an XML resource, we’ll create it dynamically for testing (and to make it changeable later!) Next we specify the view: a View to show for each datum in the list. Define an XML layout resource for that (list_item is a good name and a common idiom). For simplicity’s sake we don’t need to specify a full Layout, just a basic TextView. Have the width match_parent and the height wrap_content. Don’t forget an id! &lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/txtItem&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; To make it look better, you can specify android:minHeight=&quot;?android:attr/listPreferredItemHeight&quot; (using the framework’s preferred height for lists), and some center_vertical gravity. The android:lines property is also useful if you need more space. Finally, we specify the controller: the ListView itself. Add that item to the Activity’s Layout resource (practice: what should its dimensions be?) To finish the controller ListView, we ned to provide it with an Adapter14 which will connect the model to the view. The Adapter does the “translation” work between model and view, performing a mapping from data types (e.g., a String) and View types (e.g., a TextView). Specifically, we will use an ArrayAdapter, which is one of the simplest Adapters to use (and because we have an array of data!) An ArrayAdapter creates Views by calling .toString() on each item in the array, and setting that String as the content of a TextView! ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, R.layout.list_item_layout, R.layout.list_item_txtView, myStringArray); Note the parameters of the constructor: a Context, the item layout resource, the TextView reource, and the data array. Also note that this instance utilizes generics, since we’re using an array of Strings (as opposed to an array of Dogs or some other type). We acquire a reference to the ListView with findViewById(), and call ListView#setAdapter() to attach the adapter to that controller. ListView listView = (ListView)findViewById(R.id.listview); listView.setAdapter(adapter); And that’s all that is needed to create a scrollable list of data! Each item in this list is selectable (can have an onClick callback). This allows us to click on any item in order to (for example) view more details about the item. Utilize the AdapterView#setOnItemClickListener(OnItemClickListener) function to register the callback. The postion parameter in the onItemClick() callback is the index of the item which was clicked. Use (Type)parent.getItemAtPosition(position) to access the data value associated with that View. Additionally, each item does have an individual layout, so we can customize these appearances (e.g., if our layout also wanted to include pictures). See this tutorial for an example on making a custom adapter to fill in multiple Views with data from a list! And remember, a GridView is basically the same thing (in fact, we can just change over that and have everything work, if we use polymorphism!) 4.3 Network Data In the previous section we created a ListView utilizing an adapter to display a list of Strings. But Appendix C provides an implementation for fetching data from the Internet which gave us a list of Strings. Can we combine these? You betchya! The lecture code provides a MovieDownloader class containing the exact same networking code utilized in the Appendix. We can then simply specify that the model String[] should be the result of the downloadMovieData() method, rather than manually created with a loop. If you test this code, you’ll notice that it doesn’t work! The program will crash with a NetworkOnMainThreadException. Android apps run by default on the Main Thread (also called the UI Thread). This thread is in charge of all user interactions—handling button presses, scrolls, drags, etc.—but also UI output like drawing and displaying text! See Android Threads for more details. A thread is a piece of a program that is independently scheduled by the processor. Computers do exactly one thing at a time, but make it look like they are doing lots of tasks simultaneously by switching between them (i.e., between processes) really fast. Threads are a way that we can break up a single application or process into little “sub-process” that can be run simultaneously—by switching back and forth periodically so everyone has a chance to work Within a single thread, all method calls are synchronous—that is, one has to finish before the next occurs. You can’t get to step 4 without finishing step 3. With an event-driven system like Android, each method call is fast enough that this isn’t a problem (you’re done handling one click by the time the next occurs). But long, drawn-out processes like network access (or processing bitmaps, or accessing a database), could cause other tasks to have to wait. It’s like a traffic jam! Tasks such as network access are blocking method calls, which stop the Thread from continuing. A blocked Main Thread will lead to the infamous “Application not responding” (ANR) error! Thus we need to move the network code off the Main Thread, onto a background thread, thereby allowing it to run without blocking the user interaction that occurs on the Main Thread. To do this, we will use a class called ASyncTask15 to perform a task (such as network access) asynchronously—without waiting for other Threads. Learning Android Development involves knowing about what classes exist, and can be used to solve problems, but how were we able to learn about the existing of this highly useful (and specialized) ASyncTask class? We started from the official API Guide on Processes and Threads Guide16, which introduces this class! Thus to learn about new Android options, read the docs. Note that an ASyncTask background thread will be tied to the lifecycle of the Activity: if we close the Activity, the network connection will die as well. A better but much more complex solution would be to use a Service—which is covered in a future lecture. But since this example just involves getting a small amount of data, we don’t really care if the network connection gets dropped. ASyncTask can be fairly complicated, but is a good candidate to practice learning from the API documentation. Looking at that documentation, the first thing you should notice (or would if the API was a little more readable) is that ASyncTask is abstract, meaning you’ll need to subclass it in order to use it. Thus you can subclass it as an inner class inside the Activity that will use it (MovieDownloadTask is a good name). You should also notice that ASyncTask is a generic class with three (3) generic parameters: the type of the Parameter to the task, the type of the Progress measurement reported by the task, and the type of the task’s Result. We can fill in what types of Parameter and Result we want from our asynchronous method (e.g., take in a String and return a String[]), and use the Void type for the Progress measurement (since we won’t be tracking that). When we “run” an AsyncTask, it will do four (4) things, represented by four methods: onPreExecute() is called on the UI thread before we run the task. This method can be used to perform any setup for the task. doInBackground(Params...) is called on the background thread to do the work we want to be performed asynchronously. We must override this method (it’s abstract!) The params and return type for the method need to match the ASyncTask generic types. onProgressUpdate() can be indirectly called on the UI thread if we want to update our progress (e.g., update a progress bar). Note that UI changes can only be made on the UI thread! onPostExecute(Result) is called on the UI thread to process any task results, which are passed as parameters to this method when doInBackground is finished. The doInBackground() is what occurs on the background thread (and is the heart of the task), so we put our network accessing method call in there. We can then instantiate a new ASyncTask object in the Activity’s onCreate() callback, and call ASyncTask#execute(params) to start the task running on its own thread. If you test this code, you’ll notice that it still doesn’t work! The program will crash with a SecurityException. As a security feature, Android apps by default have very limited access to the overall operating system (e.g., to do anything other than show a layout). An app can’t use the Internet (which might consume people’s data plans!) without explicit permission from the user. This permission is given by the user at install time. In order to get permission, the app needs to ask for it (“Mother may I…”). We do that by declaring that the app uses the Internet in the Manifest.xml file (which has all the details of our app!) &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; &lt;!-- put this ABOVE the &lt;application&gt; tag --&gt; Note that Marshmallow introduced a new security model in which users grant permissions at run-time, not install time, and can revoke permissions whenever they want. To handle this, you need to add code to request “dangerous” permissions (like Location, Phone, or SMS access; Internet is not dangerous) each time you use it. For “normal” permissions (e.g., Internet), you declare the permission need in the Manifest. For “dangerous” permissions (e.g., Location), you declare the permission need in the Manifest and request permission programmatically in code each time you want to use it. Once we’ve requested permission (and have been granted that permission by virtue of the user installing our application), we can finally connect to the Internet to download data. We can log out the request results to provide it. In order to get the downloaded data into a ListView, we utilize the doPostExecute() method. This method is run on the UI Thread so we can use it to update the View (we can only change the View on the UI Thread, to avoid collisions). It also gets the results returned by doInBackground() passed to it! We take that passed in String[] and put that into the ListView. Specifically, we feed it into the Adapter, which then works to populate the views. First clear out any previous data items in the adapter using adapter.clear(). Then use adapter.add() or (adapter.addAll()) to add each of the new data items to the Adapter’s model. You can call notifyDataSetChanged() on the Adapter to make sure that the View knows the data has changed, but this method is already called by the .add() method so isn’t necessary in this situation. To finalize the app: we can enable the user to search for different movies by copying the EditText and Button Views from the previous input_layout resource, accessing the text from the former when the later is pressed. We can then pass the EditText content String into the ASyncTask#execute() function (since we’ve declared that the generic ASyncTask takes that type as the first Parameter). We can actually pass in multiple String arguments using the String... params spread operator syntax (representing an arbitrary number of items of that type). See here for details. The value that the ASyncTask methods actually get is an array of the arguments. In the end, we are able to downlod data from the Internet and show an interactive list of that data in the app! We’ve done a whirl-wind tour of Android in this process: Layouts in the XML, Adapters in the Activity, Threading in a new class, Security in the Manifest… bringing lots of parts together to provide a particular piece of functionality. https://developer.android.com/guide/topics/ui/layout/listview.html↩ https://developer.android.com/reference/android/widget/Adapter.html↩ https://developer.android.com/reference/android/os/AsyncTask.html↩ https://developer.android.com/guide/components/processes-and-threads.html↩ "],
["fragments.html", "Lecture 5 Fragments 5.1 Creating a Fragment 5.2 Dynamic Fragments", " Lecture 5 Fragments This lecture discusses Android Fragments. A Fragment is “a behavior or a portion of user interface in Activity.” You can think of them as “mini-activities” or “sub-activities”. Fragments are designed to be reusable and composable, so you can mix and match them within a single screen of a user interface. While XML resource provide reusable and composable views, Fragments provide reusable and composable controllers. Fragments allow us to make re-usable pieces of Activities that can have their own layouts, data models, event callbacks, etc. This lecture references code found at https://github.com/info448-s17/lecture05-fragments. Note that this code builds upon the example developed in Lecture 4. Fragments were introduced in API 11 (Honeycomb), which provided the first “tablet” version of Android. Fragments were designed to provide a UI component that would allow for side-by-side activity displays appropriate to larger screens. Fragment example, from Google17 Instead of needing to navigate between two related views (particularly for this “master and detail” setup), the user can see both views within the same Activity… but those “views” could also be easily split between two Activities for smaller screens, because their required controller logic has been isolated into a Fragment. Fragments are intended to be modular, reusable components. They should not depend on the Activity they are inside, so that you can be flexible about when and where they are displayed! Although Fragments are like “mini-Activities”, they are always embedded inside an Activity; they cannot exist independently. While it’s possible to have Fragments that are not visible or that don’t have a UI, they still are part of an Activity. Because of this, a Fragment’s lifecycle is directly tied to its containing Activity’s lifecycle. (e.g., if the Activity is paused, the Fragment is too. If the Activity is destroyed, the Fragment is too). However, Fragments also have their own lifecycle with corresponding lifecycle callbacks functions. Fragment lifecycle state diagram,from Google18 The Fragment lifecycle is very similar to the Activity lifecycle, with a a couple of additional steps: onAttach(): called when the Fragment is first associated with (“added to”) an Activity, and thus gains a Context. This callback is generally used for initializing communication between the Fragment and its Activity. This callback is mirrored by onDetach(), for when the Fragment is removed from an Activity. onCreateView(): called when the View (the user interface) is about to be drawn. This callback is used to establish any details dependent on the View (including adding event listeners, etc). Note that code intializing data models, or anything that needs to be persisted across configuration changes, should instead be done in the onCreate() callback. onCreate() is not called if the fragment is retained (see below). This callback is mirrored by onDestroyView(), for when the Fragment’s UI View hierarchy is being removed from the screen. onActivityCreated(): called when the containing Activity’s onCreate() method has returned, and thus indicates that the Activity is fully created. This is useful for retained Fragments. This callback has no mirror! 5.1 Creating a Fragment In order to illustrate how to make a Fragment, we will refactor the MainActivity to use Fragments for displaying the list of movies. This will help to illustrate the relationship between Activities and Fragments. To create a Fragment, you subclass the Fragment class. Let’s make one called MovieFragment (in the MovieFragment.java file). You can use Android Studio to do this work: via the File &gt; New &gt; Fragment &gt; Fragment (blank) menu option. (DO NOT select any of the other options for in the wizard for now; they provide template code that can distract from the core principles). There are two versions of the Fragment class: one in the framework’s android.app package and one in the android.support.v4 package. The later package refers to the Support Library. These are libraries of classes designed to make Android applications backwards compatible: for example, Fragment and its related classes came out in API 11 so aren’t in the android.app package for earlier devices. By including the support library, we can include those classes as well! Support libraries also include additional convenience and helper classes that are not part of the core Android package. These include interface elements (e.g., ConstraintLayout, RecyclerView, or ViewPager) and accessibility classes. See the features list for details. Thus it is often useful to include and utilize support library versions of classes so that you don’t need to “roll your own” versions of these convenience classes. The main disadvantage to using support libraries is that they need to be included in your application, so will make the final .apk file larger (and may potentially require workarounds for method count limitations). You will also run into problems if you try and mix and match versions of the classes (e.g., from different versions of the support library). But as always, you should avoid premature optimization. Thus in this course you should default to using the support library version of a class when given a choice! After we’ve created the MovieFragment Java file, we’ll want to specify a layout for that Fragment (so it can be shown on the screen). As part of using the New Fragment Wizard we were provided with a fragment_movie layout that we can use. Since we want the Movie list to live in that Fragment, we can move (copy) the View definitions from activity_main into fragment_movie. We will then adjust activity_main so that it instead contains an empty FrameLayout. This will act as a simple “container” for our Fragment (similar to an empty &lt;div&gt; in HTML). Be sure to give it an id so we can refer to it later!. It is possible to include the Fragment directly through the XML, using the XML to instantiate the Fragment (the same way that we have the XML instantiate Buttons). We do this by specifying a &lt;fragment&gt; element, with a android:name attribute assigned a reference to the Fragment class: &lt;fragment android:id=&quot;@+id/frag_movie&quot; android:name=&quot;edu.uw.fragmentdemo.MovieFragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; Defining the Fragment in the XML works (and will be fine to start with), but in practice it is much more worthwhile to instantiate the Fragemnts dynamically at runtime in the Java code—thereby allowing the Fragments to be dynamically determined and changed. We will start with the XML version to built the Fragment, and then shift to the Java version. We can next begin filling in the Java logic for the Fragment. Android Studio provides a little starter code: a constructor and the onCreateView() callback—the later is more relevant since we will use that to set up the layout (similar to in the onCreate() function of MainActivity). But the MainActivity#onCreate() method specifies a layout by calling setContentView() and pasing a resource id. With Fragments, we can’t just “set” the View because the Fragment belongs to an Activity, and so will exist inside its View hierarchy! Instead, we need to figure out which ViewGroup the Fragment is inside of, and then inflate the Fragment inside that View. This “inflated” View is referred to as the root view: it is the “root” of the Fragment’s View tree (the View that all the Views inside the Fragment’s layout will be attached to). We access the root view by inflating the fragment’s layout, and saving a reference to the inflated View: View rootView = inflater.inflate(R.layout.fragment_layout, container, false); Note that the inflater object we are calling inflate() on is passed as a parameter to the onCreateView() callback. The parameters to the inflate() method are: the layout to inflate, the ViewGroup (container) into which the layout should be inflated (also passed as a parameter to the callback), and whether ot not to “attach” the inflated layout to the container (false in this case because the Fragment system already handles the attachment, so the inflate method doesn’t need to). The onCreateView() callback must return the inflated root view, so that the system can perform this attachment. With the Fragment’s layout defined, we can start moving functionality from the Activity into the Fragment. The the background ASyncTask can be moved over directly, so that it belongs to the Fragment instead of the Activity. The adapter declaration will need to be moved as well. The UI setup (including initializing the Adapter) will be moved from the Activity’s onCreate() to the Fragment’s onCreateView(). However, you will need to make a few changes during this refactoring: The findViewById() method is a method of the Activity class, and thus can’t be called on an implicit this inside the Fragment. Instead, the method can be called on the root view, searching just that View and its children. The Adapter’s constructor requires a Context as its first parameter; while an Activity is a Context, a Fragment is not—Fragments operate in the Context of their containing Activity! Fragments can refer to the Activity that they are inside (and the Context it represents) by using the getActivity() method. Note that this method is used primarily for getting a reference to a Context, not for arbitrart commuication withe Activity (see below for details) 5.1.1 Activity-to-Fragment Communication The example code intentionally has left the input controls (the search field and button) in the Activity, rather than making them part of the Fragment. Apart from being a useful demonstration, this allows the Fragment to have a single purpose (showing the list of movies) and would let us change the search UI independent of the displayed results. But since the the button is in the Activity but the downloading functionality is in the Fragment, we need a way for the Activity to “talk” to the Fragment. We thus need a reference to the contained Fragment—access to the XML similar to that provided by findViewById. We can get a reference to a contained Fragment from an Activity by using a FragmentManager. This is an object responsible for (ahem) managing Fragment. It allows us to “look up” Fragments, as well as to manipulate which Fragments are shown. We access this FragmentManager by calling the getSupportFragmentManager() method on the Activity, and then can use findFragmentById() to look up an XML-defined Fragment by its id: //MovieFragment example MovieFragment fragment = (MovieFragment)getSupportFragmentManager().findFragmentById(R.id.fragment); Note that we’re using a method to explicit access the support FragmentManager. The Activity class (API level 15+) is able to work with both the platform and support FragmentManager classes. But because these classes don’t have a shared interface, the Activity needs to provide different Java methods which can return the correct type. Once you have a reference to the Fragment, this acts just like an other object—you can call any public methods it has! For example, if you give the Fragment a public method (e.g., searchMovies()), then this method can be called from the Activity: //called from Activity on the referenced fragment fragment.searchMovies(searchTerm) (The parameter to this public method allows the Activity to provide information to the Fragment!) At this point, the program should be able to be executed… and continue to function in exactly the same way! The program has just been refactored, so that all the movie downloading and listing work is encapsulated inside a Fragment that can be used in different Activities. In effect, we’ve created our own “widget” that can be included in any other screen, such as if we always wanted the list of movies to be available alongside some other user interface components. 5.2 Dynamic Fragments The real benefit from encapsulating behavior in a Fragment is to be able to support multiple Fragments within a single Activity. For example, in the the archetypal “master/detail” navgiation flow, one screen (Fragment) holds the “master” (list) and another screen (Fragment) holds details about a particular item. This is a very common navigation pattern for Android apps, and can be seen in most email or news apps. On large screens, Fragments allow these two screens to be placed side by side! In this section, we will continue to refine the Movie app so that when the user clicks on a Movie in the list, the app shows a screen (Fragment) with details about the selected movie. 5.2.1 Instantiating Fragments To do this, we will need to instantiate the Fragments dynamically (in Java code), rather than statically in the XML using the &lt;fragment&gt; element. This is because we need to be able to dynamically change which Fragment is currently being shown, which is not possibly for Fragments that are “hard-coded” in the XML. Unlike Activities, Fragments (such as MovieFragment) do have constructor methods that can be called—in fact, Android requires that every Fragment include a default (no-argument) constructor that is called when Fragments are created by the system. While we are able to call this constructor, it is considered best practice to not call this constructor directly when you want to instantiate a Fragment, and to in fact leave the method empty. This is because we do not have full control over when the constructor is executed: the Android system may call the no-argument constructor whenever it needs to recreate the Activity (or just the Fragment), which can happen at arbitrary times. Since only this default constructor is called, we can’t add an additional constructor with any arguments we may want the Fragment to have (e.g., the searchTerm)… and thus it’s best to not use it at all. Instead, we specify a simple factory method (by convention called newInstance()) which is able to “create” an instance of the Fragment for us. This factory method can take as many arguments as we want, and then does the work of passing these arguments into the Fragment instantiated with the default constructor: public static MyFragment newInstance(String argument) { MyFragment fragment = new MyFragment(); //instantiate the Fragment Bundle args = new Bundle(); //an (empty) Bundle for the arguments args.putString(ARG_PARAM_KEY, argument); //add the argument to the Bundle fragment.setArguments(args); //add the Bundle to the Fragment return fragment; //return the Fragment } In order to pass the arguments into the new Fragment, we wrap them up in a Bundle (an object containing basic key-value pairs). Values can be added to a Bundle using an appropriate putType() method; note that these do need to be primative types (int, String, etc.). The Bundle of arguments can then be assignment to the Fragment by calling the setArguments() method. We will be able to access this Bundle from inside the Fragment (e.g., in the onCreateView() callback) by using the getArguments() method (and getType() to retrieve the values from it). This allows us to dynamically adjust the content of the Fragment’s Views! For example, we can run the downloadMovieData() function using this argument, fetching movie results as soon as the Fragment is created (e.g., on a button press). Since the Bundle is a set of key-value pairs, each value needs to have a particular key. These keys are usually defined as private constants (e.g., ARG_PARAM_KEY in the above example) to make storage and retrieval easier. We will then be able to instantiate the Fragment (e.g., in the Activity class), passing it any arguments we wish: MyFragment fragment = MyFragment.newInstance(&quot;My Argument&quot;); 5.2.2 Transactions Once we’ve instantiated a Fragment in the Java, we need to attach it to the view hierarchy: since we’re no longer using the XML &lt;fragment&gt; element, we need some other way to load the Fragment into the &lt;FrameLayout&gt; container. We do this loading using a FragmentTransaction19. A transaction represents a change in the Fragment that is being displayed. You can think of this like a bank (or database) transaction: they allow you to add or remove Fragments like we would add or remove money from a bank account. We instantiate new transactions representing the change we wish to make, and then “run” that transaction in order to apply the change. To create a transaction, we utilize the FragmentManager again; the FragmentManager#beginTransaction() method is used to instantiate a new FragmentTransaction. Transactions represent a set of Fragment changes that are all “applied” at the same time (similar to depositing and withdrawing money from multiple accounts all at once). We specify these transactions using by calling the add(), remove(), or .replace() methods on the FragmentTransaction. The add() method lets you specify which View container you want to add a particular Fragment to. The remove() method lets you remove a Fragment you have a reference to. The replace() method removes any Fragments in a container and then adds the specified Fragment instead. Each of these methods returns the modified FragmentTransaction, so they can be “chained” together. Finally, we call the commit() method on the transaction in order to “submit” it and have all of the changes go into effect. We can do this work in the Activity’s search click handler to add a Fragment, rather than specifying the Fragment in the XML: FragmentTransaction transaction = getSupportFragmentManager().beginTransaction(); //params: container to add to, Fragment to add, (optional) tag transaction.add(R.id.container, myFragment, MOVIE_LIST_FRAGMENT_TAG); transaction.commit(); The third argument for the add() method is a “tag” we apply to the Fragment beign added. This gives it a name that we can use to find a reference to this Fragment later if we want (via FragmentManager#findFragmentByTag(tag)). Alternatively, we can save a reference to the Fragment as an instance variable; this is faster but more memory intensive (and can cause possible leaks, since the reference keeps the Fragment from being reclaimed by the system). 5.2.3 Inter-Fragment Communication We can use this structure for instantiating and loading (via transactions) a second Fragment (e.g., a “detail” view for a selected Movie). We can add functionality (e.g., in the onClick() handler) so that when the user clicks on a movie in the list, we replace() the currently displayed Fragment with this new detailed Fragment. However, remember that Fragments are supposed to be modular—each Fragment should be self-contained, and not know about any other Fragments that may exist (after all, what if we wanted the master/detail views to be side-by-side on a large screen?) Using getActivity() to reference the Activity and getSupportFragmentManager() to access the manager is a violation of the Law of Demeter—don’t do it! Instead, we have Fragments communicate by passing messages through their contained Activity: the MovieFragment should tell its Activity that a particular movie has been selected, and then that Activity can determine what to do about it (e.g., creating a DetailFragment to dispaly that information). The recommended way to provide Fragment-to-Activity communication is to define an interface. The Fragment class should specify an interface (for one or more public methods) that its containing Activity must support—and since the Fragment can only exist within an Activity that implements that interface, it knows the Activity has the specified public methods that it can call to pass information to that Activity. As an example of this process: Create a new interface inside the Fragment (e.g., OnMovieSelectedListener). This interface needs a public method (e.g., onMovieSelected(Movie movie)) that the Fragment can call to give instructions or messages to the Activity. In the Fragment’s onAttach() callback (called when the Fragment is first associated with an Activity), we can check that the Activity actually implements the interface by trying to cast it to that interface. We can also save a reference to this Activity for later: public void onAttach(Context context) { super.onAttach(context); try { callback = (OnMovieSelectedListener)context; } catch (ClassCastException e) { throw new ClassCastException(context.toString() + &quot; must implement OnMovieSelectedListener&quot;); } } Then when an action occurs in the Fragment (e.g., a movie is selected), you call the interface’s method on the callback reference. Finally, you will need to make sure that the Activity implements this callback. Remember that a class can implement multiple interfaces! In the Activity’s implementation of the interface, you can handle the information provided. For example, use the FragmentManager to create a replace() transaction to load a new DetailFragment for the appropriate data. In the end, this will allow you to have one Fragment cause the application to switch to another! This is not the only way for Fragments to communicate. It is also possible to have a Fragment send an Intent to the Activity, who then responds to that as appropriate. But using the Intent system is more resource-intensive than using interfaces. 5.2.4 The Back Stack But what happens when we hit the “back” button? The Activity exits! Why? Because “back” normally says to “leave the Activity”—we only had one Activity, just multiple fragments. Recall that the Android system may have lots of Activities (even across multiple apps!) with the user moving back and forth between them. As described in lecture2, each new Activity is associated with a “task” and placed on a stack20. When the “back” button is pressed, that Activity is popped off the stack, and the user is taken to the Activity that is now at the top. Fragments by default are not part of this “back-stack”, since they are just components of Activities. However, you can specify that a transaction should include the Fragment change as part of the stack navigation by calling FragmentTransaction#addToBackStack() as part of your transaction (e.g., right before you commit()): getSupportFragmentManager().beginTransaction() .add(detailFragment, &quot;detail&quot;) // Add this transaction to the back stack .addToBackStack() .commit(); Note that the “back” button will cause the entire transaction to “reverse”. Thus if you performed a remove() then an add() (e.g., via a replace()), then hitting “back” will cause the the previously added Fragment to be removed and the previously removed Fragment to be added. FragmentManager also includes numerous methods for manually manipulating the back-stack (e.g., “popping” off transactions) if necessary. https://developer.android.com/images/fundamentals/fragments.png↩ https://developer.android.com/images/fragment_lifecycle.png↩ https://developer.android.com/reference/android/support/v4/app/FragmentTransaction.html↩ http://developer.android.com/images/fundamentals/diagram_backstack.png↩ "],
["ui-components.html", "Lecture 6 UI Components 6.1 The Action Bar 6.2 Menus 6.3 Dialogs 6.4 Toasts", " Lecture 6 UI Components This lecture discusses how to include menus and pop-up dialogs in an Android application as additional navigation and display components. Note that this lecture aims to provide exposure rather than depth to these concepts; for further details and options, see the official Android documentation. This lecture references code found at https://github.com/info448-s17/lecture06-menus-dialogs. 6.1 The Action Bar Let’s start one of the most prominent visual components in the default app: the App Bar or Action Bar. This acts as the sort of “header” for your app, providing a dedicated space for navigation and interaction (e.g., through menus). The ActionBar21 is a specific type of Toolbar that is most frequenly used as the App Bar, offering a particular “look and feel” common to Android applications. While the AppCompatActivity used throughout this course automatically provides an Action Bar for the app, it is also possible to add it directly (such as if you are using a different Activity subclass). To add your own Action Bar, you specify a theme that does not include an ActionBar, and then include an &lt;android.support.v7.window.Toolbar&gt; element inside your layout wherever you want the toolbar to go. See Setting up the App Bar for details. This will also allow you to put the Toolbar anywhere in the application’s layout (e.g., if you want it to be stuck to the bottom). To see this in action, change the android:theme attribute of the &lt;application&gt; element in the Manifest to &quot;@style/Theme.AppCompat.Light.NoActionBar&quot;. We’ll discuss this process in more detail when we talk about Themes and Styles. From in the Activity’s Java code, we can get access to the Action Bar by calling the getSupportActionBar() method (for a support Toolbar). We can then call utility methods on this object to interact with it; for example .hide() will hide the toolbar! 6.2 Menus However, the main use for the Action Bar is a place to hold Menus. A Menu (specifically, an options menu) is a set of items (think: buttons) that appear in the Action Bar. Menus can be specified both in the Activity and in a Fragment; if declared in both places, they are combined into a single menu in the Action Bar. This allows you to easily make “context-specific” options menus that are only available for an appropriate Fragment, while keeping Fragments modular and self-contained. Fun fact: before API 11, options menus appeared as buttons at the bottom of the screen! Menus, like all other user-facing elements, are defined as XML resources, specifically of type menu. You can create a new menu resource through Android studio using File &gt; New &gt; Android resource file and then choosing the Menu Resource type. This will create an XML file with a main &lt;menu&gt; element. Options can be added to the menu by specifying child XML elements, particularly &lt;item&gt; elements. Common &lt;item&gt; attributes include: android:id: a unique id used to refer to the specific option in the Java code android:title (required attribute): the text to display for the option. As user-facing text, the content should ideally be defined as an XML String resource. app:showAsAction: whether or not the option should be listed in the Action Bar, or collapsed under a “three-dots” button. Note when working with the appcompat library, this option uses the app namespace (instead of android); you will need to include this schema in the &lt;menu&gt; with the attribute xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;. android:icon: an image to use when showing the option as a button on the menu //CHECK THIS You can use one of the many icons built into the Android, referenced as &quot;@android:drawable/ic_*&quot;. Android Drawables22 includes the full list, though not all drawables are publicly available through Android Studio. android:orderInCategory: used to order the item in the menu (or in a group). This acts as a “priority” (default 0; low comes first). Such prioritizing can be useful if you want to add suggestions about whether Fragment options should come before or after the Actiity options. See the Menu resources guide23 for the full list of options! It is possible to include one level of sub-menus (a &lt;menu&gt; element inside an &lt;item&gt; element). Menu items can also be grouped together by placing them inside of a &lt;group&gt; element. All items in a group will be shown or hidden together, and can be further ordered within that group. Grouped icons can also be made checkable. In order to show the menu in the running application, we need to tell the Action Bar which menu resource it should use (there may be a lot of resources). To do this, we override the onCreateOptionsMenu() callback in the Activity or Fragment, and then use the component’s MenuInflater object to expand the menu: public boolean onCreateOptionsMenu(Menu menu) { MenuInflater inflater = getMenuInflater(); inflater.inflate(R.menu.main_menu, menu); //inflate into this menu return true; } This procedure is similar in concept to how a Fragment’s onViewCreated() method would inflate the Fragment into the Activity. In this case, the Menu is being inflated into the Action Bar. We can respond to the menu items being selected by overriding the onOptionsItemSelected() callback. By convention, we use a switch on the item.getItemId() to determine what item was selected, and then act accordingly. public boolean onOptionsItemSelected(MenuItem item) { switch(item.getItemId()){ case R.id.menu_item1 : //do thing; return true; default: return super.onOptionsItemSelected(item); } } On default (if the item selected isn’t handled by any cases), we pass the callback up to super for “higher-level” components to check. For exampe, if a the menu option isn’t handled by the Fragment (because the Fragment didn’t add it), the event can be passed up through the Framework for eventually handling by the Activity (who did add it). This method should return true if the selection even has been handled (and thus should not be considered by anyone else). Return false if you want other components (e.g., other Fragments) to be able to respond to this option as well. There are many other menu items that can be placed on Action Bar as well. We can also add Action Views that provide more complex interactions than just clicking buttons (for example, including a search bar). An Action Provider (like ShareActionProvider) is an action with its own customized layout, expanding into a separate View when clicked. We wil discuss how to utilize these features in a future lecture. 6.2.1 Context Menus In addition to options menus available in the Action Bar, we can also specify contextual menus that pop up when the user long-presses on an element. This works similarly to using an options menu, but with a different set off callbacks: When setting up the the View layout (e.g., in an Activity’s onCreate()), we specify that an element has a context menu using the registerForContextMenu() method, passing it the View we want to be able to create the menu for. Specify the context menu to use through the onCreateContextMenu() callback. This works exactly like setting up an options menu. In fact, a context menu can even use the same menu as an options menu! This reuse is one of the advantages of defining the user interface as XML. And mirroring the options menu, respond to context menu items being selected with the onContextItemSelected() callback. This section has provided a very brief introduction to menus, but there are many more complex interactions that they support. I highly recommend that you read through the guide in order to learn what features may be available. If you ever are using an app and wonder “how did they add this interface feature?”, look it up! There is almost always a documented procedure and example for providing that kind of component. 6.3 Dialogs While it is simple enough to make menu items that log out some text, logs cannot be seen the user. Instead, we woud like to show the message to the user as a kind of “pop-up” message. A Dialog24 is a “pop-up” modal (a view which doesn’t fill the screen) that either asks the user to make a decision or provides some additional information. At it’s most basic, Dialogs are similar to the window.alert() function used in JavaScript. There is a base Dialog class, but almost always we use a pre-defined subclass instead (similar to how we’ve use AppCompatActivity). AlertDialog25 is the most common version: a simple message with buttons you can respond with (confirm, cancel, etc). We don’t actually instantiate an AlertDialog directly (in fact, it’s constructors are protected so inaccessible to us). Instead we use a helper factory class called an AlertDialog.Builder. There are a number of steps to use a builder to create a Dialog: Instantiate a new builder for this particular dialog. The constructor takes in a Context under which to create the Dialog. Note that once the builder is initialized, you can create and recreate the same dialog with a single method call—that’s the benefits of using a factory. Call “setter” methods on the builder in orer to specify the title, message, etc. for the dialog that will appear. This can be hard-coded text or a reference to an XML String resource (as a user-facing String, the later is more appropriate for published applications). Each setter method will return a reference to the builder, making it easy to chain them. Use appropriate setter methods to specify callbacks (via a DialogInterface.OnClickListener) for individual buttons. Note that the “positive” button normally has the text &quot;OK&quot;, but this can be customized. Finally, actually instantiate the AlertDialog with the builder.create() method, using the show() method to make the dialog appear on the screen! AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle(&quot;Alert!&quot;) .setMessage(&quot;Danger Will Robinson!&quot;); builder.setPositiveButton(&quot;I see it!&quot;, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int id) { // User clicked OK button } }); AlertDialog dialog = builder.create(); dialog.show(); An important part of learning to develop Android applications is being able to read the API to discover effective options. For example, can you read the AlertDialog.Builder API and determine how to add a “cancel” button to the alert? While AlertDialog is the most common Dialog, Android supports other subclasses as well. For example, DatePickerDialog and TimePickerDialog provide pre-defined user interfaces for picking a date or a time respectively. See the Pickers guide for details about how to utilize these. 6.3.1 DialogFragments The process described above will create and show a Dialog, but that dialog has a few problems in how it interacts with the rest of the Android framework—namely with the lifecycle of the Activity in which it is embedded. For example, if the device changes configurations (e.g., is rotated from portrait to landscape) then the Activity is destroyed and re-created (it’s onCreate() method will be called again). But if this happens while a Dialog is being shown, then a android.view.WindowLeaked error will be displayed and the Dialog is lost! To avoid these problems, we need to have a way of giving that Dialog its own lifecycle which can interact with the the Activity’s lifecycle… sort of like making it a modular piece of an Activity… that’s right, we need to make it a Fragment! Specifically, we will use a subclass of Fragment called DialogFragment, which is a Fragment that displays as a modal dialog floating above the Activity (no extra work needed). Just like with the Fragment examples from the previous lecture, we’ll need to create our own subclass of DialogFragment. It’s often easiest to make this a nested class if the Dialog won’t be doing a lot of work (e.g., shows a simple confirmation). Rathern than specifying a Fragment layout through onCreateView(), we can instead override the onCreateDialog() callback to specify a Dialog object that will provide the view hierarchy for the Fragment. This Dialog can be created with the AlertDialog.Builder class as before! public static class MyDialogFragment extends DialogFragment { public static HelloDialogFragment newInstance() { Bundle args = new Bundle(); HelloDialogFragment fragment = new HelloDialogFragment(); fragment.setArguments(args); return fragment; } public Dialog onCreateDialog(Bundle savedInstanceState) { AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); //... AlertDialog dialog = builder.create(); return dialog; } } Finally, we can actually show this DialogFragment by instantiating it (remember to use a newInstance() factory method!) and then calling the show() method on it to make it show as a Dialog. The show() method takes in a FragmentManager used to manage this transaction. By using a DialogFragment, it is possible to change the device configuration (rotate the phone) and the Dialog is retained. Here’s the other neat trick: a DialogFragment is just a Fragment. That means we can use it anywhere we normally used Fragments… including embedding them into layouts! For example if you made the MoviesFragment subclass DialogFragment instead of Fragment, it would be able to be used in the exact same as before. It’s still a Fragment, just with extra features—one of which is a show() method that will show it as a Dialog! Use setStyle(DialogFragment.STYLE_NO_TITLE, android.R.style.Theme_Holo_Light_Dialog) to make the Fragment look a little more like a dialog. The truth is that Dialogs are not very commonly used in Android (compare to other GU systems). Apps are more likely to just dynamically change the Fragment or Activity being shown, rather than interrupt the user flow by creating a pop-up modal. And 80% of the Dialogs that are used are AlertDialogs. Nevertheless, it is worth being familiar with this process and the patterns it draws upon! 6.4 Toasts Dialogs are a powerful way of providing messages and information to users, but they are pretty “heavy” in terms of both their interaction (they stop all other interaction to show the user a message) and the effort required to implement them. Sometimes you just want a “pop-up” message that isn’t quite as prominent and doesn’t require the user to click “okay” once they’ve seen it. A simple, quick way of giving some short visual feedback is to use what is called a Toast. This is a tiny little text box that pops up at the bottom of the screen for a moment to quickly display a message. It’s called a “Toast” because it pops up! Toasts are pretty simple to implement, as with the following example (from the official documentation): Context context = this; //getApplicationContext(); //use application context to avoid disappearing if Activity is closed quickly. String text = &quot;Hello toast!&quot;; int duration = Toast.LENGTH_SHORT; //use factory method instead of constructor Toast toast = Toast.makeText(context, text, duration); toast.show(); But since this Activity is a Context, and we can just use the Toast anonymously, we can shorten this to a one-liner: Toast.makeText(this, &quot;Hello toast!&quot;, Toast.LENGTH_SHORT).show(); Boom, a quick visual alert method we can use for proof-of-concept stuff! Toasts are intended to be a way to provide information to the user (e.g., giving them quick feedback), but they can possibly be useful for testing too (though in the end, Logcat is going to be your best bet for debugging, especially when trying to solve crashes or see more complex output). http://developer.android.com/reference/android/support/v7/app/ActionBar.html↩ http://androiddrawables.com/↩ https://developer.android.com/guide/topics/resources/menu-resource.html↩ https://developer.android.com/guide/topics/ui/dialogs.html↩ https://developer.android.com/reference/android/support/v7/app/AlertDialog.html↩ "],
["providers-and-loaders.html", "Lecture 7 Providers and Loaders 7.1 Content Providers 7.2 Cursors 7.3 Loaders 7.4 Other Provider Actions", " Lecture 7 Providers and Loaders This lecture discusses how to access data from a Content Provider using a Loader. A Content Provider is an abstraction of a data base or other data store, allowing us easily systematically work with that data in Java (rather than in a separate data manipulation language such as SQL). A Loader is then used to efficiently perform this data access in the background (off the UI Thread), while also easily connecting that data to Views. This lecture references code found at https://github.com/info448-s17/lecture07-loaders. 7.1 Content Providers Consider the WordListFragment utilized by the example code (though these concepts apply to any Fragment or Activity). This Fragment includes a ListView that shows a list of words. Recall that a ListView utilizes the model-view-controller architecture… and in this case, the “model” (data) is a hard-coded list of array of words. But there are other lists of words as well! Entire databases of words! Previous lectures have discussed how to use network requests to access online data APIs, but there are also databases (of words no less) built into your Android phone. For example, Android keeps track of the list of the spellings of “non-standard” words in what is called the User Dictionary. You can view this list on the device at Settings &gt; Language &amp; Input &gt; Personal Dictionary. You can even use this Settings interface to add new words to the dictionary (e.g., “embiggen”, “cromulent”, “fleek”). Note that the User Dictionary keeps track of a database of words. You can think of this database as being like a single SQL table: it’s a set of entries (rows) each of which have some values (columns). The primary key of the table is named (by convention) ID. While you don’t need to know SQL to utilize a built-in database like the User Dictionary, it helps to have a passing familiarity with relational databases (e.g., what is taught in the iSchool’s INFO 340 course). Since this data is stored in a (essentially) a simple SQL table, it is possible for us to access and modify it programmatically&amp;mash;moreover, the Android framework allows us to do this without needing to know or write SQL! For example, we can access this list of words in order to show them in the WordFragment’s ListView. To do this, we’ll need to request permission to access the database, just as we asked permission to access the Internet. Include the following in the Manifest: &lt;uses-permission android:name=&quot;android.permission.READ_USER_DICTIONARY&quot;&gt; Although the words are stored in a database, we don’t know the exact format of this database (e.g., exact table or column names, or even whether it is an SQL database or just a .csv file!). We want to avoid having to write code that only works with a specific format, especially as the words may be stored in different kinds of databases on different devices or across different versions of Android. (The Android framework does include support for working directly with a local SQLite database, but it is a lot more work, requires knowing SQL, and produces a more fragile application). In order to avoid relying on the specific format of how some data is stored, Android offers an abstraction in the form of a Content Provider. A Content Provider offers an interface to interact with structured data, whether that data is stored in a database, in a file, in multiple files, online, or somewhere else. You can thus think of “a Content Provider” as meaning “a data source” (e.g., the source/provider of content)! It is possible to create your own Content Providers (described in a later lecture), but this lecture focuses purely on utilizing existing Providrs. All Content Providers (data sources) have a URI (Universal Resource Indicator, a generalization of a URL used for resources not necessarily on the Internet). It is possible to query this URI, similar in concept to how web APIs are accessed via queries to their URI endpoints. In particular, Content Provider URIs utilize the content:// protocol (instead of https://), since the their data is accessed as via “content requests” rather than “HTTP requests”. The URI for the Dictionary’s content is defined by the constant UserDictionary.Words.CONTENT_URI. We utilize constants to refer to URIs and paths to make it easier to refer to them and to generalize across devices that may have different directory structures. We are able to access this Content Provider via a ContentResolver. This class provides methods for accessing the data in a provider (represented as a ContentProvider object). Each Context has a singleton ContentResolver, which is accessed via the getContentResolver() method (note that for a Fragment, the Context is the containing Activity). The ContentResolver’s methods support the basic CRUD operations: insert(), query(), update(), and delete(). ContentResolver methods take multiple parameters, supporting the different options available in a generic SQL query. For example, consider the the query() method: getContentResolver().query( uri, // The content URI projection, // The an array of columns to return for each row selectionClause // Selection criteria (as an SQL WHERE clause) selectionArgs, // An array of values that can be injected into the selection clause sortOrder); // The sort order for the returned rows (as an SQL ORDER BY clause) This is basically a wrapper around an SQL SELECT statement! The projection is a String[] of all the “columns” (attributes) we want to fetch from the data source. This is what you’d put after SELECT in SQL. (Note we can pass in null to represent SELECT *, but that’s inefficient—better to give a list of everything). We can see what column names are available for the User Dictionary in UserDictionary.Words. Again, these are defined as constants! Be sure to always select the _ID primary key: it will be needed later! The other parameters can be used to customize the SELECT statement. THe “selection” (WHERE) clause needs to parameters: the second are values that will be escaped against SQL injection attacks. Passing null for any of these parameters will cause the clause to be ignored: ContentResolver resolver = getActivity().getContentResolver(); String[] projection = new String[] { UserDictionary.Words.WORD, UserDictionary.Words._ID }; resolver.query(UserDictionary.Words.CONTENT_URI, projection, null, null, null); So overall, the query is breaking apart the components SQL SELECT statement into different pieces as parameters to a method, so you don’t quite have to write the selection yourself. Moreover, this method abstracts the specific query language, allowing the same queries to be used on different formats of database (SQLite, PostgreSQL, files, etc). 7.2 Cursors The ContentResolver#query() method returns a Cursor. A Cursor provides an interface to the list of records in a database (e.g., those returned by the query). A Cursor also behaves like an Iterator in Java: it keeps track of which record is currently being accessed (e.g., what the i would be in a for loop). You can think of it as a “pointer” to a particular record, like the cursor on a screen. We call methods on the Cursor to specify which record we want it to “point” to, as well as to fetch values from the record object at that spot in the list. For example: cursor.moveToFirst(); //move to the first item String field0 = cursor.getString(0); //get the first field (column you specified) as a String String name = cursor.getString(cursor.getColumnIndexOrThrow(&quot;word&quot;)); //get the &quot;word&quot; field as a String cursor.moveToNext(); //go to the next item The nice thing about Cursors though is that they can easily be fed into AdapterViews by using a CursorAdapter (as opposed to the ArrayAdapter we’ve used previously). The SimpleCursorAdapter is a concrete implementation that is almost as easy to use as an ArrayAdapter: You instantiate a new SimpleCursorAdapter, passing it: A Context for loading resources A layout resource to inflate for each record A Cursor (which can be null) An array of column names to fetch from each entry in the Cursor (the projection, similar to before) A matching list of View resource ids (which should all be TextViews) to assign each column’s value to. This is the “mapping” that the Adapter will perform (from projection columns to TextView contents). Any additional option flags (0 means no flags, and is the correct option for us). Then we can use this adapter for the ListView in place of the ArrayAdapter! 7.3 Loaders In order to get the Cursor to pass into the adapter, we need to .query() the database. But we’ll be doing this a lot, and so would like to do it off the UI Thread—database accessing is slow! And every time we do that query (or any other database manipulation), we want to update the Adapter so that the changes to the list show up. In order to easily update your list with new data loaded on a background thread, we’re going to use a class called a Loader. This is basically a wrapper around ASyncTask, but one that lets you execute a backgroup task repeatedly whenever the data source changes. In particular, Android provides a CursorLoader specifically used to load data from ContentProviders through Cursors—whenever the content changes, a new Cursor is produced which can be “swapped” into the adapter. To use a CursorLoader, we need to specify that our Fragment implements the LoaderManager.LoaderCallback&lt;Cursor&gt; interface—basically saying that this fragment can react to Loader events. Loaders need to work with Fragments, unless the Activity subclasses FragmentActivity (as AppCompatActivity does) and thereby provides the “Fragment” capabilities needed to use a Loader. So we can use Loaders in our Activities or Fragments. We will need to fill in the interfaces callbacks functions in order to use the CursorLoader: In onCreateLoader() we specify what the Loader should do. Here we would instantiate and return a new CursorLoader(...) that queries the ContentProvider. This looks a lot like the .query() method we wrote earlier, but will run on a background thread! In the onLoadFinished() callback, we can swap() the Cursor into our SimpleCursorAdapter in order to feed that model data into our controller (for display in the view). See the guide for more details. In the onLoaderReset() callback just swap in null for our Cursor, since there now is no content to show (the loaded data has been “reset”). Finally, in order to actually start our background activity, we’ll use the getLoaderManager().initLoader(...) method. This is similar in flavor to the AsyncTask.execute() method we’ve used before (using a manager similar to the FragmentManager). getLoaderManager().initLoader(0, null, this); The first parameter to the initLoader() method is an id number for which cursor you want to load, and is passed in as the first param to onCreateLoader() (or is accessible via Loader#getId()). This allows you to have multiple Loaders using the same callback function (e.g., a Fragment can handle multiple Loaders for multiple data sources). The second param is a Bundle of args, and the third is the LoaderCallbacks (e.g., who handles the results)! Note that you can use the .restartLoader() method to “recreate” the CursorLoader (without losing other references), such as if you want to change the arguments passed to it. And with that, we can fetch the words from our database on a background thread—and if we update the words it will automatically change! 7.4 Other Provider Actions 7.4.1 Adding Words To insert a new Word into the ContentProvider, we just call a different method on the ContentResolver: //Example from Google: ContentValues mNewValues = new ContentValues(); mNewValues.put(UserDictionary.Words.APP_ID, &quot;edu.uw.loaderdemo&quot;); mNewValues.put(UserDictionary.Words.LOCALE, &quot;en_US&quot;); mNewValues.put(UserDictionary.Words.WORD, word); mNewValues.put(UserDictionary.Words.FREQUENCY, &quot;100&quot;); Uri mNewUri = getContentResolver().insert( UserDictionary.Words.CONTENT_URI, // the user dictionary content URI mNewValues // the values to insert ); Note that we specify the “details” of the Word in a ContentValues object, which is a HashMap almost exactly like a Bundle (but only supports values that work with ContentProviders) "],
["intents.html", "Lecture 8 Intents 8.1 Intents for Another Activity (Explicit) 8.2 Intents for Another App (Implicit) 8.3 Intents for a Response 8.4 Listening for Intents 8.5 Broadcasts and Receivers 8.6 An Example: SMS 8.7 ShareActionProvider", " Lecture 8 Intents This lecture discusses how to use Intents to communicate between different Activities and Applications. The Intent system allows Activities to communicate, even though they don’t have references to each other (and thus we can’t just call a method on them). This lecture references code found at https://github.com/info448-s17/lecture08-intents. Note that you will need to have a working camera on your device. To enable the camera in the emulator, use the Tools &gt; Android &gt; AVD menu to modify the emulator, and select “webcam” for the front camera option. Confirm that it is enabled by launching the Camera app. An Intent is a message that is sent between app components, allowing them to communicate! Most object communication we do is via direct method call; you have a reference to an Object and then you call a method on it. We’ve also seen event callbacks, where on an event one of our callbacks gets executed by the system (really just a wrapper around direct method call via the Observer pattern) Intents step outside of this a little bit: they allow us to create objects that can be “given” to another component (read: Activity), who can then respond upon receiving that. Similar to an event callback, but working at a slightly higher system level. You can think of Intents as like letters you’d send through the mail: they are addressed to a particular target (e.g., another Activity—more properly a Context), and have room for some data called extras to go inside (held in a Bundle). When the envelope arrives, the recipient can get that data out and do something with it… and possibly sending a response back. Note that there are couple of different kinds of Intents; we’ll go through examples of each. 8.1 Intents for Another Activity (Explicit) The most basic kind of Intent is an Intent sent to a specific Activity/Context, such as for telling that Activity to open. An Intent26 is an object we can instantiate: for example, we can create a new Intent in the event handler for when we click the button on MainActivity. The Intent class has a number of different constructors, but the one we’ll start with looks like: // context, target Intent intent = new Intent(MainActivity.this, SecondActivity.class); The first parameter refers to the current Context in which the message should be delivered. The second parameter to this constructor is the class we want to send the Intent to (the .class property fetches a reference to the class type; this is metaprogramming!). Effectively, it is the “address” on the envelop for the message we’re sending. We’re using MainActivity.this as the context, because the this would refer to the anonymous listener class (for methods in Main, we can just use this). After having instantiated the new Intent, we can use that message to start an Activity by calling the startActivity() method (inherited from Activity), passing it the Intent: startActivity(intent); This method will “send” the message to the operating system, which will deliver the Intent to the appropriate Activity, telling that Activity to start as soon as it receives the message. And we can use the back button to go backwards! See the Activities lecture for details. This is called an Explicit Intent because we’re explicit about what target we want to receive it. It’s a letter to a specific Activity. 8.1.1 Extras We can also specify some extra data inside our envelope. These data are referred to as Extras. This is a Bundle (so a set of primitive key-value pairs) that we can use to pass limited information around! intent.putExtra(&quot;package.name.key&quot;,&quot;value&quot;); Docs say that best practice is to include the full package name on keys, so avoid any collisions or misreading of data. There are also some pre-defined values (constants) that you can use in the Intent class. We can then get the extras from the Intent in the Activity that receives it: //in onCreate(); Bundle extras = getIntent().getExtras(); //All activities are started with an Intent! String value = extras.getString(&quot;key&quot;); So we can have Activities communicate, and even share information between them! Yay! 8.2 Intents for Another App (Implicit) We can send Intents to our own Activities, but we can even address them to other Apps. When calling on other apps, we usually use Implicit Intents. This is a little bit like letters that have weird addresses27, but still get delivered. “For that guy at the end of the block with the red mailbox.” An Implicit Intent includes an Action and some Data. The Action says what the target should do upon receiving the intent (a Command), and the Data gives more detail about what to run that action on. Actions can be things like ACTION_VIEW to view some data, or ACTION_PICK to choose an item from a list. See a full list under “Standard Action Activities”. ACTION_MAIN is the most common (just start the Activity as if it were a “main” launching point). So when we don’t specify anything else, this is used! Data gives detail about what to do with the action (e.g., the Uri to VIEW or the Contact to DIAL). Extras then support this data! For example, if we specify a DIAL action, then we’re saying that we want our Intent to be delivered to an App that is capable of dialing a telephone number. - If there is more than one app that supports this action, the user will pick one! This is key: we’re not saying exactly what app to use, just what kind of functionality we need to be supported! It’s a kind of abstraction! Intent intent = new Intent(Intent.ACTION_DIAL); intent.setData(Uri.parse(&quot;tel:206-685-1622&quot;)); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } Here we’ve specified the Action (ACTION_DIAL) for our Intent, as well as some Data (a phone number, converted into a Uri). The resolveActivity() method looks up what Activity is going to receive our action–we check that it’s not null before trying to start it up. This should allow us to “dial out” ! Note that we can open up all sorts of apps. See Common Intents28 for a list of common implicit events (with examples!). 8.3 Intents for a Response We’ve been using intents to start Activities, but what if we’d like to get a result back from the Activity? That is, what if we want to look up a Contact or take a Picture, and then be able to use the Contact or show the Picture? To do this, we’re going to create Intents in the same way, but use a different method to launch them: startActivityForResult(). This will launch the resolved Activity. But once that Action is finished, the launched Activity will send another Intent back to us, which we can then react to in order to handle the result. This is a bit like including an “RSVP” note in a letter! For fun, let’s do it with the Camera–we’ll launch the Camera to take a picture, and then get the picture and show it in an ImageView we have. Note that your Emulator will need to have Camera emulation on! See Taking Photos Simply for walkthrough. In the activity, we can specify an intent that uses the MediaStore.ACTION_IMAGE_CAPTURE action (the action for “take a still picture and return it”). The “request code” is used to distinguish this intent from others we may send (kind of like a “tag”). Note that we could pass an Extra for where we want to save the large picture file to. However, we’re going to leave that off and just work with the thumbnail for this demonstration. See the guide29 for details; if time we can walk through it! static final int REQUEST_IMAGE_CAPTURE = 1; private void dispatchTakePictureIntent() { Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); if (takePictureIntent.resolveActivity(getPackageManager()) != null) { startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE); } } In order to handle the “response” Intent, we need to provide a callback that will get executed when that Intent arrives. Called onActivityResult(). We can get information about the Intent we’re receiving from the params. And we can get access to the returned data (e.g., the image) by getting the &quot;data&quot; field from the extras. Note that this is a Bitmap, which is the Android class representing a raster image. We’ll play with Bitmaps more in a couple weeks, because I like graphics. @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { if (requestCode == REQUEST_IMAGE_CAPTURE &amp;&amp; resultCode == RESULT_OK) { Bundle extras = data.getExtras(); Bitmap imageBitmap = (Bitmap) extras.get(&quot;data&quot;); mImageView.setImageBitmap(imageBitmap); } } 8.4 Listening for Intents We’re able to send implicit Intents that can be heard by other Apps, but what if we wanted to receive implicit Intents ourselves? What if we want to be able to handle phone dialing?! In order to receive an implicit Intent, we need to declare that our Activity is able to handle that request. Since we’re specifying an aspect of our application, we’ll do this in the Manifest using what is called an &lt;intent-filter&gt;. The idea is that we’re “hearing” all the intents, and we’re “filtering” for the ones that are relevant to us. Like sorting out the junk mail. An &lt;intent-filter&gt; tag is nested inside the element that it applies to (e.g., the &lt;activity&gt;). In fact, you can see there is already one there: that responds to the MAIN action sent with the LAUNCHER category (meaning that it responds to intents from the app launcher). Similarly, we can specify three “parts” of the filter: a &lt;action android:name=&quot;action&quot;&gt; filter, which describes the Action we can respond to. a &lt;data ...&gt; filter, which specifies aspects of the data we accept (e.g., only respond to Uri’s that look like telephone numbers) a &lt;category android:name=&quot;category&quot;&gt; filter, which is basically a “more information” piece. You can see the “Standard Categories” in the documentation. Note that you must include the DEFAULT category to receive implicit intents. This is the category used by startActivity() and startActivityForResult. Note that you can include multiple actions, data, and category tags. You just need to make sure that you can handle all possible combinations selected from each type (they are “or” not “and” filters!) Responding to that dial command: &lt;activity android:name=&quot;SecondActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.DIAL&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;tel&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; You can see many more examples in the Intent documentation. 8.5 Broadcasts and Receivers There is one other kind of Intent I want to talk about: Broadcasts. A broadcast is a message that any app can receive. Unlike Explicit and Implicit Intents, broadcasts are heard by the entire system–anything you “shout” with a broadcast is publicly available (security concerns!) Mass mailings question mark? Other than who receives them, broadcasts work the same as normal implicit intents! We create an Intent with an Action and Data (and Category and Extras…). But instead of using the startActivity() method, we use the sendBroadcast() method. That intent can now be heard by all Activities on the phone, We’ll skip a demo for time and motivation… we’ll generate broadcasts later in the course. But more common than sending broadcasts will be receiving broadcasts; that is, we want to listen and respond to System broadcasts that are produced (things like power events, wifi status, etc). Or more germane to this week’s homework–to incoming text messages!! We can receive broadcasts by using a BroadcastReceiver. This is a base class that is used by an class that can receive broadcast Intents. We subclass it and implement the onReceive(Context, Intent) callback in order to handle when broadcasts are received. public void onReceive(Context context, Intent intent) { Log.v(&quot;TAG&quot;, &quot;received! &quot;+intent.toString()); else if(intent.getAction() == Intent.ACTION_BATTERY_LOW){ Toast.makeText(context, &quot;Battery is low!&quot;, Toast.LENGTH_SHORT).show(); } } But in order to register our receiver (so that intents go past its desk), we also need to specify it in the Manifest. We do this by including a &lt;receiver&gt; attribute inside our &lt;application&gt;. Note that this is not an Activity, but a separate component! We can put an &lt;intent-filter&gt; inside of this to filter for broadcasts we care about. &lt;receiver android:name=&quot;.MyReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.ACTION_POWER_CONNECTED&quot; /&gt; &lt;action android:name=&quot;android.intent.action.ACTION_POWER_DISCONNECTED&quot; /&gt; &lt;action android:name=&quot;android.intent.action.BATTERY_CHANGED&quot; /&gt; &lt;action android:name=&quot;android.intent.action.BATTERY_OKAY&quot; /&gt; &lt;!-- no category because not for an activity! --&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; We can test these power events easily using the latest version of the emulator. In the “extra options” button (the three dots at the bottom) in the emulator’s toolbar, we can get to the Battery tab where we can effectively change the battery status of the device (which our app can respond to!) Note that there is a Phone tab where you can send Text Messages to the emulator… you’ll need this for your homework this week. We can also register these receivers in code (rather than in the manifest). This is good for if we only want to temporarily listen for some kind of events, or if we want to determine the intent-filter on the fly. IntentFilter batteryFilter = new IntentFilter(); batteryFilter.addAction(Intent.ACTION_BATTERY_LOW); batteryFilter.addAction(Intent.ACTION_BATTERY_OKAY); batteryFilter.addAction(Intent.ACTION_POWER_CONNECTED); batteryFilter.addAction(Intent.ACTION_POWER_DISCONNECTED); this.registerReceiver(new MyReceiver(), batteryFilter); We’re dynamically declaring an intent-filter as well! This can be used not just for BroadcastReceivers, but Activities too. 8.6 An Example: SMS One specific use of Intents is when working with text messages (SMS, Short Messaging Service, the most popular form of data communication in the world). While it is possile to fetch a list of messages usin a ContentProvider, it is also possible to send SMS as well. This will also let us show off one more type of Intent. Important note: the SMS APIs changed drastically in KitKat (API 19). So we’re going to make sure that is our minimum so we can get all the helpful methods and support newer stuff (check gradle to confirm!). The main thing to note about sending SMS is that as of KitKat, each system has a default messaging client—who is the only one who can actually send messages. Luckily, the API lets you get access to that messaging client’s services in order to send a message through it: SmsManager smsManager = SmsManager.getDefault(); smsManager.sendTextMessage(&quot;5554&quot;, null, &quot;This is a test message!&quot;, null, null); // target, message We will need permission: &lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot; /&gt; If we look at the documentation for this method30, you can see that this works by looking at the inbox in the Messages app… but there is another way as well. Those last two parameters are for PendingIntents: one for when messages are sent and one for when messages are delivered. What’s a PendingIntent? The details are not super readable… It’s basically a wrapper around an Intent that we give to another class. Then when that class receives our PendingIntent and reacts to it, it can run the Intent (command) we sent it with as if that Activity was us (whew). Basically we’re saying “when I call you, you can come pick me up using my car” kind of thing. Or like if you gave a stamped envelope to someone to put your letter or recommendation inside (do this!) So the idea is we specify what Intent should be delivered when the message is finished being sent (that Intent becomes “pending”). Effectively, this let’s us send Intents in response to some other kind of event. Let’s go ahead and set one up: public static final String ACTION_SMS_STATUS = &quot;edu.uw.intentdemo.ACTION_SMS_STATUS&quot;; ... Intent intent = new Intent(ACTION_SMS_STATUS); PendingIntent pendingIntent = PendingIntent.getBroadcast(MainActivity.this, 0, intent, 0); smsManager.sendTextMessage(&quot;5554&quot;, null, &quot;This is a test message!&quot;, pendingIntent, null); We’re doing a couple of steps here: We’re defining out own custom Action. It’s just a String, but name-spaced to avoid conflicts We then create an implicit intent for this action And then create a PendingIntent. We’re using the getBroadcast() method to specify that the intent should be sent via a Broadcast (c.f. getActivity() for startActivity()). First param is content that should send the intent, then a request code (e.g., for result callbacks if we wanted), then the Intent, and finally any extra flags (none for now). We can then have our BroadcastReceiver respond to this Intent just like any other one! if(intent.getAction() == MainActivity.ACTION_SMS_STATUS) { if (getResultCode() == Activity.RESULT_OK) { Toast.makeText(context, &quot;Message sent!&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(context, &quot;Error sending message&quot;, Toast.LENGTH_SHORT).show(); } } Don’t forget to add our custom intent to the &lt;intent-filter&gt;! We’ll see more with PendingIntents in the next chapter when we talk about notifications. 8.7 ShareActionProvider But wait there’s more we can do with Intents One of the other things we can add to menus are Action Views that are expandable widgets in the action bar (e.g., search example). Or, to play around with Intents more, we can add an Action Provider (like ShareActionProvider), which gives us a bunch of interaction built into the menu! This is the “quick share with these social media sites” button that we see commonly. We’d want to look at class documentation for how to set this up (it’s much clearer than the training docs). How to use it: We’re going to add another item to our menu’s XML. This will look like most items, except it will have an extra field app:actionProviderClass &lt;item android:id=&quot;@+id/menu_item_share&quot; android:title=&quot;Share&quot; app:showAsAction=&quot;ifRoom&quot; app:actionProviderClass=&quot;android.support.v7.widget.ShareActionProvider&quot; /&gt; We’ll then add the item to our menu in onCreateOptionsMenu() MenuItem item = menu.findItem(R.id.menu_item_share); mShareActionProvider = (ShareActionProvider) MenuItemCompat.getActionProvider(item); Intent intent = new Intent(Intent.ACTION_DIAL); intent.setData(Uri.parse(&quot;tel:206-685-1622&quot;)); mShareActionProvider.setShareIntent(intent); We get access to the item using findItem(), and then cast it to a ShareActonProvider (make sure you’re using the support version!) We can then specify an implicit Intent that we want that “Share Button” to be able to perform. This would commonly use the ACTION_SEND action (like for sharing a picture or text), but we’ll use the DIAL action because we have a couple of dialers but don’t actually have many SEND responders on the emulator. The Menu item will then list a dropdown with all of the different Activities that resolve to handling that implicit intent! http://developer.android.com/reference/android/content/Intent.html↩ http://www.theguardian.com/world/2015/jul/18/postman-turns-detective-to-deliver-letter-with-cryptic-address-in-ireland↩ http://developer.android.com/guide/components/intents-common.html↩ http://developer.android.com/training/camera/photobasics.html#TaskPath↩ https://developer.android.com/reference/android/telephony/SmsManager.html↩ "],
["ui-components-ii.html", "Lecture 9 UI Components II 9.1 Notifications 9.2 Settings", " Lecture 9 UI Components II This lecture discusses how to include additional user interface components in an Android application: namely Notifications31 and Settings Menus. As before, this lecture aims to provide exposure rather than complete coverage to these concepts; for more options and examples, see the official Android documentation. This lecture references code found at https://github.com/info448-s17/lecture09-notifications-settings. 9.1 Notifications We have previously covered how to let the user know what’s going on by popping up a toast or even an AlertDialog, but often we want to notify the user of something outside of the normal Activity UI (e.g., when the app isn’t running, or without getting in the way of other interactions). To do this, we can use Notifications. These are specialized views that show up in the notification area (the icons at the top of the operating system display) and in the system’s notification drawer, which the user can get to at any point—even when outside the app—by swiping down on the screen. Android’s documentation for UI components is overall quite thorough and usable (after all, Google wants to make sure that developers can build effective apps, thereby making the platform worthwhile). And because there are so many different UI elements and they change all the time, in order to do real-world Android development you need to be able to read, synthesize, and apply this documentation. As such, this lecture will demonstrate how to utilize that documentation and apply it to create notifications. We will utilize this documentation in order to add a feature that when we click on the appropriate menu button, a notification will appear that reports how many times we’ve selected that option. To follow along this, open up the Notifications documentation. Looking at the documentation we see an overview to start. There is also a link to the Notification Design Guide, which is a good place to go to figure out how to design effective notifications. There is a lot of text about how to make a Notification… I personally prefer to work off of sample code, modifying it until I have something that does what I want, so I’m going to scroll down slowly until I find an example I can copy/paste in, or at least reference. Then we can scroll back up later to get more detail about how that code works. Eventually you’ll find a subsection “Creating a Simple Notification”, which souds like a great place to start! The first part of this Notification is using NotificationCompat.Builder (use the v4 support version). We have previously seen this kind of Builder class with AlertBuilder, and the same concept applies here: it is a class used to construct the Notification for us. We call setters to specify the properteis of the Notification I don’t have a drawable resource to use for an icon, which makes me want to not include the icon specification. However, scrolling back up will reveal that a notification icon is required, so we will need to make one. We can produce an new Image Asset for the notificaton icon (File &gt; New &gt; Image Asset), just as we did previously with launcher icons. Specify the “type” as Notification, give it an appropriate name, and pick a clipart of your choosing. The next line makes an Intent. We’ve done that too… but why create an Intent for a Notificatoin? If we scroll up and look where Intent is referenced, we can find out about Notification Actions, which specify what happens when the user clicks on the Notification. Usually this opens the relevant application, and since Intents are messages to open Activities, it makes sense that clicking a Notification would send an Intent. Notice that the Intent will actually be wrapped in a PendingIntent. Thus we will give the Notification a PendingIntent, which contains an “RSVP” (to open the Activity) that it can send to the system when someone clicks on it. (the Intent is “pending” delivery/activation by another service). In particular, we use a PendingIntent in order to make sure that the Activity who will be executing it (the “notification service” component) will have permission to send the contained Intent. The Intent the notification service sends is to wake up our Activity, run with our permissions. It is as if we had sent the Intent ourselves! The example Notification is also using the a TaskStackBuilder to construct an “artificial” backstack. This is used to specify, for example, that if the user clicks on the Notification and jumps to a “detail” view (say), they can still hit the back button to return to the “master” view, as if they had navigated to the “detail” view following a normal application phone. We build this backstack not just with methods, but by integrating with the “parent-child” relationship we’ve otherwise set up between Activities. In the Manifest, we had specified that SecondActivity's parent is MainActivity. This is what gave us the nice back button in the ActionBar. These sequence of parentActivityName attributes form a hierarchy that will be the “back navigation hierarchy.” We add the “endpoint” of the hierarchy to the builder using addParentStack(MyResultActivity.class), and then finally put the Intent we actually want to use “on top” of the stack with addNextIntent(resultIntent). The resultIntent is not the PendingIntent… yet. While we could define a PendingIntent manually, the example uses the TaskStackBuilder#getPendingIntent() method to build an appropriate PendingIntent object. Pass it an ID to refer to that request (like we’ve done when sending Intents for Results), and a flag PendingIntent.FLAG_CURRENT_UPDATE so that if we re-issue the PendingIntent it update instead of replace the pending Intent. We can then assign that PendingIntent to the Notification builder (with setContentIntent()). Finally, we can use the NotificationManager (similar to the FragmentManager, SmsManager, etc.) to fetch the notification service (the “application” that handles all the notifications for the OS). We tell this manager to actually issue the built Notification object. We also pass the notify() method an ID number to refer to the particular Notification (not the PendingIntent, but the Notification). Again, this will allow us to refer to and update that Notification. This allows us to have working Notifications! We can click the button to launch a Notification, and then click on the Notification to be taken to our app, which has a working back stack! We can also update this notification later, and it’s really straightforward: we simply re-issue a Notification with the same ID number, and it will “replace” the previous one! For example, we can have our text be based on some instance variable, and have the Notification track the number of clicks! You may notice that this notification doesn’t “pop up” in a way we might expect. This is because its priority isn’t high enough (it needs to be NotificationCompat.PRIORITY_HIGH or higher) and because it doesn’t use either sound or vibration (it needs to be really important to get a heads-up pop). We can make the Notification vibrate by using the setVibrate() method, passing it an array of times (in milliseconds) at which to turn vibration on and off. Pattern is [delay, vibrate, sleep, vibrate, sleep, ...] ` --> We can also assign a default sound with (e.g.,) builder.setSound(Settings.System.DEFAULT_NOTIFICATION_URI); See the design guide for best practices on priority. As always, there are a number of other pieces/details we can specify, but I leave those to you to look up in the documentation. As a focus on development, this lecture references but does not discuss the UI Design guidelines: e.g., what kind of text should you put in your Notification? When should you choose to use a notification? Android has lots of guidance on these questions in their “design” documentation, and further HCI and Mobile Design guidelines apply here just as well. In general, this course will leave the UI design up to you. But major guidelines apply (e.g., make actions obvious, give feedback, avoid irreversible actions, etc.). 9.2 Settings The second topic of this lecture is to support letting the user decide whether clicking the button should create notifications or not. For example, maybe sometimes the user just want to see Toasts! The cleanest way to support this kind of user preference is to create some Settings using Preferences. 9.2.1 SharedPreferences Shared Preferences32 are another way that we can persist data in application (besides putting it into a database via a ContentProvider, or using the file system as described in the next lecture). SharedPreferences store key-value pairs of primitives (Strings, ints, etc), similar to what we’ve been putting in Bundles. This data will be stored across application sessions: if I save some data to the Preferences and close the app, it will be there when I come back. Preferences are stored in an XML File in the file system. Basically we save in lists of key-value pairs as a basic XML tree in a plain-text file. Note that this is not a resource, rather a file that happens to be structured as XML. This is not great for intricate or extensive structured data (since it only stores key-value pairs, and only primitives at that). Use other options for more complex data persistence. Even though they are called “Preferences”, they not just for “user preferences”. We can persist any small bits of primitive data in a Preferences file. We can get access to this SharedPreferences file using the .getSharedPreferences(String, int) method. The first parameter String is the name of the Preference File we want to access (we can have multiple XML files; just use getPreferences() to use a single default). The second parameter int is a flag about whether other apps should have access to that file. MODE_PRIVATE (0) is the default, MODE_WORLD_READABLE and MODE_WORLD_WRITEABLE are the other options. We can edit this XML file by calling .edit() on the SharedPreferences object to get a SharedPreferences.Editor, which is a Bundle-esque object we can put values into. We need to call .commit() on the editor to save our changes to the file system! Finally, we can just call get() methods on the SharedPreferences object in order to fetch data out of it! The second parameter of these methods is a default value for if a preference doesn’t exist yet, making it easy to avoid null errors. For practice, try saving the notification count in the Activity’s onStop() function, and retrieving it in onCreate(). This will allow you to persist the count even when the Activity is destroyed. 9.2.2 Preference Settings While SharedPreferences acts a generic data store, it is called Shared Preferences because it’s most commonly used for “user preferences”—e.g., the “Settings” for an app. The “Preference Menu” is a user-facing element, so we’ll want to define it as an XML resource. But we’re not going to try and create our own layout and interaction: instead we’re just going to define the list of Preferences33 themselves as a resource! We can create a new resource using Android Studio’s New Resource wizard. The “type” for this is actually just XML (generic), though our “root element” will be a PreferenceScreen (thanks intelligent defaults!). By convention, the preferences resource is named preferences.xml Inside the PreferenceScreen, we add more elements: one to represent each preference we want to let the user adjust (or each “line” of the screen Settings window). We can define different types of Preference objects, such as &lt;CheckBoxPreference&gt;, &lt;EditTextPreference&gt;, &lt;SwitchPreference&gt;, or &lt;ListPreference&gt; (for a dialog of radio buttons). There are a couple of other options as well; see the Preference base class. These elements should include the following XML attributes (among others): android:key the key to store the preference in the SharedPreferences file android:title a user-visible name android:defaultvalue a default value for the preference (use true or false for checkboxes). More options cam be found in the the Preference documentation. We can further divide these Preferences to organize them: we can place them inside a PreferenceCategory tag (with its own title and key) in order to group them together. Finally we can specify that our Preferences have multiple screens by nesting PreferenceScreen elements. This produces “subscreens” (like submenus): when we click on the item it will take us to the next screen. Note that a cleaner (but more labor-intensive) way to do this if you have lots of settings is to use preference-headers which allows for better multi-pane layouts… but since we’re not making any apps with that many settings this process is left as exercise for the reader. Once we have the Preferences all defined in XML: we just need to show them in our application! To do this, we’re going to use the PreferenceFragment class (a specialized Fragment for showing lists of Preference objects). We don’t need to specify an onCreateView() method, instead we’re just going to load that Preference resource in the onCreate() method using addPreferencesFromResource(R.xml.preferences). This will cause the PreferenceFragment to create the appropriate layout! We’ll put this Fragment inside a plain Activity, which just loads that Fragment via a FragmentTransaction: getFragmentManager().beginTransaction() .replace(android.R.id.content, new SettingsFragment()) .commit(); The Activity doesn’t even need to load a layout: just specify a transaction! But if we want to include other stuff (e.g., an ActionBar), we’d need to structure the Activity and its layout in more detail. Note that android.R.id.content refers to the “root element” of the current View–basically what setContentView() is normally inflating into. There is a PreferenceActivity class as well, but the official recommendation is do not use it. Many of its methods are deprecated, and since we’re using Fragments via the support library, we should stick with the Fragment process. Finally, how do we interact with these settings? Here’s the trick: a preferences XML resource is automatically associated with a SharedPreferences file. And in fact, every time we adjust a setting in the PreferenceFragment, the values in that file are edited as well! We never need to write to the file, just read from it (similar to any other SharedPreferences file). The preference XML corresponds to the “default” SharedPreferences file, which we’ll access via: SharedPreferences sharedPref = PreferenceManager.getDefaultSharedPreferences(this); And then we have this object we can fetch data from with getString(), getBoolean(), etc. This will allow us to check the preferences before we show a notification! That’s the basics of using Settings. For more details see the documentation, as well as the design guide for best practices on how to organize your Settings. https://developer.android.com/guide/topics/ui/notifiers/notifications.html↩ https://developer.android.com/guide/topics/data/data-storage.html#pref↩ https://developer.android.com/reference/android/preference/Preference.html↩ "],
["files-and-permissions.html", "Lecture 10 Files and Permissions 10.1 File Storage Locations 10.2 Permissions 10.3 External Storage 10.4 Internal Storage &amp; Cache 10.5 Example: Saving Pictures 10.6 Sharing Files", " Lecture 10 Files and Permissions This lecture discusses how to working with files in Android. Using the file system allows us to have persistant data storage in a more expansive and flexible manner than using the SharedPreferences discussed in the previous lecture (and as a supplement to ContentProvider databases). This lecture references code found at https://github.com/info448-s17/lecture10-files-permissions. In order to demonstrate all of the features discussed in this lecture, your device or emulator will need to be running API 23 (6.0 Marshmallow) or later. 10.1 File Storage Locations Android devices split file storage into two types: Internal storage and External storage. These names come from when devices had built-in memory as well as external SD cards, each of which may have had different interactions. However, with modern systems the “external storage” can refer to a section of a phone’s built-in memory as well; the distinctions are instead used for specifying access rather than physical data location. Internal storage is always accessible, and by default files saved internally are only accessible to your app. Similarly, when the user uninstalls your app, the internal files are deleted. This is usually the best place for “private” file data, or files that will only be used by your application. External storage is not always accessible (e.g., if the physical storage is removed), and is usually (but not always) world-readable. Normally files stored in External storage persist even if an app is uninstalled, unless certain options are used. This is usually used for “public” files that may be shared between applications. When do we use each? Basically, you shuold use Internal storage for “private” files that you don’t want to be available outside of the app, and use External storage otherwise. Note however that there are publicly-hidden External files—the big distinction between the storage locations is less visibility and more about access. In addition, both of these storage systems also have a “cache” location (i.e., an Internal Cache and an External Cache). A cache is “(secret) storage for the future”, but in computing tends to refer to “temporary storage”. The Caches are different from other file storage, in that Android has the ability to automatically delete cached files if storage space is getting low… However, you can’t rely on the operating system to do that on its own in an efficient way, so you should still delete your own Cache files when you’re done with them! In short, use the Caches for temporary files, and try to keep them small (less than 1MB recommended). The user can easily clear an application’s cache as well. In code, using all of these storage locations involve working with the File class. This class represents a “file” (or a “directory”) object, and is the same class you may be familiar with from Java SE. We can instantiate a File by passing it a directory (which is another File) and a filename (a String). Instantiating the file will create the file on disk (but empty, size 0) if it doesn’t already exist. We can test if a File is a folder with the .isDirectory() method, and create new directories by taking a File and calling .mkdir() on it. We can get a list of Files inside the directory with the listFiles() method. See more API documentation for more details and options. The difference between saving files to Internal and External storage, in practice, simply involves which directory you put the file in! This lecture will focus on working with External storage, since that code ends up being a kind of “super-set” of implementation details needed for the file system in general. We will indicate what changes need to be made for interacting with Internal storage. This lecture will walk through implementing an application that will save whatever the user types into an text field to a file. Because a device’s External storage may be on removable media, in order to interact with it in any way we first need to check whether it is available (e.g., that the SD card is mounted). This can be done with the following check (written as a helper method so it can be reused): public static boolean isExternalStorageWritable() { String state = Environment.getExternalStorageState(); if (Environment.MEDIA_MOUNTED.equals(state)) { return true; } return false; } 10.2 Permissions Directly accessing the file system of any computer can be a significant security risk, so there are substantial protections in place to make sure that a malicious app doesn’t run roughshod over a user’s data. So in order to work with the file system, we first need to discuss how Android handles permissions in more detail. One of the most import aspect of the Android operating system’s design is the idea of sandboxing: each application gets its own “sandbox” to play in (where all its toys are kept), but isn’t able to go outside the box and play with someone else’s toys. The “toys” (components) parts that are outside of the sandbox are things that would be impactful to the user, such as network or file access. Apps are not 100% locked into their sandbox, but we need to do extra work to step outside. Sandboxing also occurs at a package level, where packages (applications) are isolated from packages from other developers; you can use certificate signing (which occurs as part of our build process automatically) to mark two packages as from the same developer if we want them to interact. Additionally, Android’s underlying OS is Linux-based, so it actually uses Linux’s permission system under the hood (with user and group ids that grant access to particular files or processes). In order for an app to go outside of its sandbox (and use different components), it needs to request permission to leave. We ask for this permission (“Mother may I?”) by declaring out-of-sandbox usages explicitly in the Manifest, as we’ve done before with getting permission to access the Internet or send SMS messages. Android permissions we can ask for are divided into two categories: normal and dangerous: Normal permissions are those that may impact the user (so require permission), but don’t pose any serious risk. They are granted by the user at install time; if the user chooses to install the app, permission is granted to that app. See this list for examples of normal permissions. INTERNET is a normal permission. Dangerous permissions, on the other hand, have the risk of violating a user’s privacy, or otherwise messing with the user’s device or other apps. These permissions also need to be granted at install time. But IN ADDITION, starting from Android 6.0 Marshmallow (API 23), users additionally need to grant dangerous permission access at runtime, when the app tries to actually invoke the “permitted” dangerous action. The user grants permission via a system-generated pop-up dialog. Note that permissions are granted in “groups”, so if the user agrees to give you RECEIVE_SMS permission, you get SEND_SMS permission as well. See the list of permission groups. When the user grant permission at runtime, that permission stays granted as long as the app is installed. But the big caveat is that the user can choose to revoke or deny privileges at any time (they do this though System settings)! Thus you have to check each time you want to access the feature if the user has granted the privileges or not—you don’t know if the user has currently given you permission, even if they had i Writing to external storage is a dangerous permission, and thus we will need to do extra work to support the Marshmallow runtime permission system. In order to support runtime permissions, we need to specify our app’s target SDK to be 23 or higher AND execute the app on a device running Android 6.0 (Marshmallow) or higher. Runtime permissions are only considered if the OS supports and the app is targeted that high. For lower-API devices or apps, permission is only granted at install time. First we still need to request permission in the Manifest; if we haven’t announced that we might ask for permission, we won’t be allowed to ask in the future. In particular, saving files to External storage requires android.permission.WRITE_EXTERNAL_STORAGE permission (which will also grant us READ_EXTERNAL_STORAGE access). Before we perform a dangerous action, we can check that we currently have permission: int permissionCheck = ContextCompat.checkSelfPermission(activity, Manifest.permission.PERMISSION_NAME); This function basically “looks up” whether we’ve been granted a particular permission or not. It will return either PackageManager.PERMISSION_GRANTED or PackageManager.PERMISSION_DENIED. If permission has been granted, great! We can go about our business (e.g., saving a file to external storage). But if permission has NOT been explicitly granted (at runtime), then we have to ask for it. We do this by calling: ActivityCompat.requestPermissions(activity, new String[]{Manifest.permission.PERMISSION_NAME}, REQUEST_CODE); This method takes a context and then an array of permissions that we need access to (in case we need more than one). We also provide a request code (an int), which we can use to identify that particular request for permission in a callback that will be executed when the user chooses whether to give us access or not. This is the same pattern as when we sent an Intent for a result; asking for permission is conceptually like sending an Intent to the permission system! We can then provide the callback that will be executed when the user decides whether to grant us permission or not: public void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) { switch (requestCode) { case REQUEST_CODE: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) { //have permission! Do stuff! } default: super.onRequestPermissionsResult(requestCode, permissions, grantResults); } } We check which request we’re hearing the results for, what permissions were granted (if any—the user can piece-wise grant permissions), and then we can react if everything is good… like by finally saving our file! Note that if the user deny us permission once, we might want to try and explain why we’re asking permission (see best practices) and ask again. Google offers a utility method (ActivityCompat#shouldShowRequestPermissionRationale()) which we can use to show a rationale dialog if they’ve denied us once. And if that’s true, we might show a Dialog or something to explain ourselves–and if they OK that dialog, then we can ask again. 10.3 External Storage Once we have permission to write to external file, we can actually do so! Since we’ve verified that the External storage is available, we now need to pick what directory in that storage to save the file in. With External storage, we have two options: We can save the file publicly. We use the getExternalStoragePublicDirectory() method to access a public directory, passing in what type of directory we want (e.g., DIRECTORY_MUSIC, DIRECTORY_PICTURES, DIRECTORY_DOWNLOADS etc). This basically drops files into the same folders that every other app is using, and is great for shared data and common formats like pictures, music, etc.. Files in the public directories can be easily accessed by other apps (assuming the app has permission to read/write from External storage!) Alternatively starting from API 18, we save the file privately, but still on External storage (these files are world-readable, but are hidden from the user as media, so they don’t “look” like public files). We access this directory with the getExternalFilesDir() method, again passing it a type (since we’re basically making our own version of the public folders). We can also use null for the type, giving us the root directory. Since API 19 (4.4 KitKat), you don’t need permission to write to private External storage. So you can specify that you only need permission for versions lower than that: xml &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; android:maxSdkVersion=&quot;18&quot; /&gt; We can actually look at the emulator’s file-system and see our files by created using adb. Connect to the emulator from the terminal using adb -s emulator-5554 shell (note: adb needs to be on your PATH). Public external files can usually be found in /storage/sdcard/Folder, while private external files can be found in /storage/sdcard/Android/data/package.name/files (these paths may vary on different devices). Once we’ve opened up the file, we can write content to it by using the same IO classes we’ve used in Java: The “low-level” way to do this is to create a a FileOutputStream object (or a FileInputStream for reading). We just pass this constructor the File to write to. We write bytes to this stream… but can write a String by calling myString.getBytes(). For reading, we’ll need to read in all the lines/characters, and probably build a String out of them to show. This is actually the same loop we used when reading data from an HTTP request! However, we can also use the same decorators as in Java (e.g., BufferedReader, PrintWriter, etc.) if we want those capabilities; it makes reading and writing to file a little easier In either case, remember to .close() the stream when done (to avoid memory leaks)! //writing try { //saving in public Documents directory File dir = getExternalStoragePublicDirectory(Environment.DIRECTORY_DOCUMENTS); if (!dir.exists()) { dir.mkdirs(); } //make dir if doesn&#39;t otherwise exist File file = new File(dir, FILE_NAME); Log.v(TAG, &quot;Saving to &quot; + file.getAbsolutePath()); PrintWriter out = new PrintWriter(new FileWriter(file, true)); out.println(textEntry.getText().toString()); out.close(); } catch (IOException ioe) { Log.d(TAG, Log.getStackTraceString(ioe)); } //reading try { File dir = getExternalStoragePublicDirectory(Environment.DIRECTORY_DOCUMENTS); File file = new File(dir, FILE_NAME); BufferedReader reader = new BufferedReader(new FileReader(file)); StringBuilder text = new StringBuilder(); //read the file String line = reader.readLine(); while (line != null) { text.append(line + &quot;\\n&quot;); line = reader.readLine(); } textDisplay.setText(text.toString()); reader.close(); } catch (IOException ioe) { Log.d(TAG, Log.getStackTraceString(ioe)); } This will allow us to have our “save” button write the message to the file, and have our “read” button load the message from the file (and display it on the screen)! 10.4 Internal Storage &amp; Cache Internal storage works pretty much the same way as External storage. Remember that Internal storage is always private to the app. We also don’t need permission to access Internal storage! For Internal storage, we can use the getFilesDir() method to access to the files directory (just like we did with External storage). This method normally returns the folder at /data/data/package.name/files. Alternatively, we can use Context#openFileOutput() (or Context#openFileInput()) and pass it the name of the file to open. This gives us back the Stream object for that file in the Internal storage file directory, without us needing to do any extra work (cutting out the middle-man!) These methods take a second parameter: MODE_PRIVATE will create the file (or replace a file of the same name). Other modes available are: MODE_APPEND (which adds to the end of the file if it exists instead of erasing). MODE_WORLD_READABLE, and MODE_WORLD_WRITEABLE are deprecated. Note that you can wrap a FileInputStream in a InputStreamReader in a BufferedReader. We can access the Internal Cache directory with getCacheDir() (and same read/write process), or the External Cache directory with getExternalCacheDir(). We almost always use the Internal Cache, because why would you want temporary files to be world-readable (other than maybe temporary images…) And again, once you have the file, you use the same process for reading and writing as External storage. For practice make the provided toggle support reading and writing to an Internal file as well. This will of course be different file than that used with the External switch. Ideally this code could be refactored to avoid duplication, but it gets tricky with the need for checked exception handling. 10.5 Example: Saving Pictures As another example of how we might use the storage system, consider the “take a selfie” system from lecture 8. The code for taking a piecture can be found in a separate PhotoActivity (which is accessible via the options menu). To review: we sent an Intent with the MediaStore.ACTION_IMAGE_CAPTURE action, and the result of that Intent included an Extra that was a BitMap of a low-quality thumbnail for the image. But if we want to save a higher resolution version of that picture, we’ll need to store that image in the file system! To do this, we’re actually going to modify the Intent we send so it includes an additional Extra: a file in which the picture data can be saved. Effectively, we’ll have our Activity allocate some memory for the picture, and then tell the Camera where it can put the picture data that it captures. (Intent envelops are too small to carry entire photos around!) Before we send the Intent, we’re going to go ahead and create an (empty) file: File file = null; try { String timestamp = new SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;).format(new Date()); //include timestamp //ideally should check for permission here, skipping for time File dir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES); file = new File(dir, &quot;PIC_&quot;+timestamp+&quot;.jpg&quot;); boolean created = file.createNewFile(); //actually make the file! Log.v(TAG, &quot;File created: &quot;+created); } catch (IOException ioe) { Log.d(TAG, Log.getStackTraceString(ioe)); } We will then specify an additional Extra to give that file’s location to the camera: if we use MediaStore.EXTRA_OUTPUT as our Extra’s key, the camera will know what to do with that! However, the extra won’t actually be the File but a Uri (recall: the “url” or location of a file). We’re not sending the file itself, but the location of that file (because it’s smaller data to fit in the Intent envelope). We can get this Uri with the Uri.fromFile(File) method: //save as instance variable to access later when picture comes back pictureFileUri = Uri.fromFile(file); Then when we get the picture result back from the Camera (in our onActivityResult callback), we can access that file at the saved Uri and use it to display the image! The ImageView.setImageUri() is a fast way of showing an image file. Note that when working with images, we can very quickly run out of memory (because images can be huge). So we’ll often want to “scale down” the images as we load them into memory. Additionally, image processing can take a while so we’d like to do it off the main thread (e.g., in an AsyncTask). This can become complicated; the recommended solution is to use a third-party library such as Glide, Picasso, or Fresco. 10.6 Sharing Files Once we have a file storing the image, we can also save that image with other apps! As always, in order to interact with other apps, we use an Intent. We can craft an implicit intent for ACTION_SEND, sending a message to any apps that are able to send (share) pictures. We’ll set the data type as image/* to mark this as an image. We will also attach the file as an extra (specifically an EXTRA_STREAM). Again note that we don’t actually put the file in the extra, but rather tha Uri for the file! Since multiple activities may support this action, we can wrap the intent in a “chooser” to force the user to pick which Activity to use: Intent chooser = Intent.createChooser(shareIntent, &quot;Share Picture&quot;); //check that there is at least one option if (shareIntent.resolveActivity(getPackageManager()) != null) { startActivity(chooser); } There is one complication though: because we’re saving files in External storage, the app who is executing the ACTION_SEND will need to have permission to read the file (e.g., to access External storage). The Messenger app on the emulator appears to lack this permission by default, though we need to take a slightly different approach: Rather than putting the file:// Uri in the Intent’s extra, we’ll need to create a content:// Uri for a ContentProvider who is able to provide files to anyone who requests them regardless of permissions (the provider grants permission to access its content). Luckily, each image stored in the public directories is automatically tracked by a ContentProvider known as the MediaStore. It easy to fetch a content:// Uri for a particular image file from this provider: MediaScannerConnection.scanFile(this, new String[] {file.toString()}, null, new MediaScannerConnection.OnScanCompletedListener() { public void onScanCompleted(String path, Uri uri) { mediaStoreUri = uri; //save the content:// Uri for later Log.v(TAG, &quot;MediaStore Uri: &quot;+uri); } }); This provides a Uri that can be given to the Intent, and that the Messenger app will be able to access! We can generate this Uri as soon as we have a file for the image to be saved in. 10.6.1 Bonus: Sharing with a FileProvider This section has not be edited for formatting or content. What happens if we try and share an Internal file? You’ll get an error (actually notified the use!), because the other (email) app doesn’t have permission to read that file! There is a way around this though, and it’s by using a ContentProvider (haha!) A ContentProvider explicit is about making content available outside of a package (that’s why we declared it in the Manifest). Specifically, a ContentProvider can convert a set of Files into a set of data contents (e.g., accessible with the content:// protocol) that can be used and returned and understood by other apps! Kind of like a “File Server” Android includes a FileProvider class in the support library that does exactly this work. Setting up a FileProvider is luckily not too complex, though it has a couple of steps. You will need to declare the &lt;provider&gt; inside you Manifest (see the guide link for an example). &lt;provider android:name=&quot;android.support.v4.content.FileProvider&quot; android:authorities=&quot;edu.uw.mapdemo.fileprovider&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/fileprovider&quot; /&gt; &lt;/provider&gt; The attributes you will need to specify are: android:authority should be your package name followed by .fileprovider (e.g., edu.uw.myapp.fileprovider). This says what source/domain is granting permission for others to use the file. The child &lt;meta-data&gt; tag includes an androd:resource attribute that should point to an XML resource, of type xml (the same as used for your SharedPreferences). You will need to create this file! The contents of this file will be a list of what subdirectories you want the FileProvider to be able to provide. It will look something like: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;files-path name=&quot;my_maps&quot; path=&quot;maps/&quot; /&gt; &lt;/paths&gt; The &lt;files-path&gt; entry refers to a subdirectory inside the Internal Storage files (the same place that .getFilesDir() points to), with the path specifying the name of the subdirectory (see why we made one called maps/?) Once you have the provider specified, you can use it to get a Uri to the “shared” version of the file using: Uri fileUri = FileProvider.getUriForFile(context, &quot;edu.uw.myapp.fileprovider&quot;, fileToShare); (note that the second parameter is the “authority” you specified in your &lt;provider&gt; in the Manifest). You can then use this Uri as the EXTRA_STREAM extra in the Intent that you want to share! "],
["accessibility.html", "Lecture 11 Accessibility 11.1 Universal Usability 11.2 Implementing Accessibility", " Lecture 11 Accessibility This chapter will discuss how to support Accessibility when developing Android applications—specifically, supporting users with levels of physical disability. Accessibility is an incredibly important software quality that is often overlooked, but making Android apps accessible requires only a few minor changes to the implementation details discussed in this course. 11.1 Universal Usability When developing any kind of interactive system, there are different design principles (e.g., Shneiderman and Plaisant’s Golden Rules) that can provide guidelines for how to develop effective and usable system. One of the most important design principles is Universal Usability (also known as Universal Design), which is the principle that designed products should be inherently accessible. This principle takes as its premise that designing for accessibility—to be usable by all people no matter their ability (physical or otherwise)—benefits not just those with some form of limitation or disability, but everyone. The classic example of Universal Design are curb cuts: the “slopes” built into curbs to accommodate people in wheelchairs. However, this design decision end up making curbs more usability for everyone: curb cuts help people with rollerbags, strollers, temporary injuries, or who just have problems climbing steps. If you design a piece of technology to be used by a person with only one arm, then you support people with a disablity. But you also support people with a temporary disability (e.g., their arm is unusable because it is in a sling or a cast), and people who are just currently inconvenienced (e.g., they are holding a baby in that arm). You make the interaction and life better for everyone. Universal usability is equally important in the domain of mobile design: If you support people with vision impairments (e.g., by providing touch and voice controls), you also support people who just want to use the app while driving or otherwise visually occupied. If you support people who cannot afford high-end devices with unlimited 4G connections (e.g., by functioning on older versions of Android, or being frugal when downloading data), you also support people who are currently without data connections (being out in the woords, on an airplane, over their data plan, etc). People with disabilities cannot ethically be excluded from consideration in app design, and by considering their needs you will also improve the usability of your app for all population—two for the price of one! This guideline is increasingly being acknowledged by companies as key to usability, and thus it is important that you apply it to your own design work. 11.2 Implementing Accessibility The Android framework provides a number of ways to make apps more accessible, including a handy accessibility developer checklist that you can follow. Some specific actions are described in more detail below: you should perform the listed tasks to test and improve an app’s accessibility. These exercises build on the lecture code found at https://github.com/info448-s17/lecture07-loaders (use the completed branch). You will need to adjust MainActivity so that it shows the provided MovieFragment by default; you will be testing and improving the accessibility of that Fragment. 11.2.1 Supporting Vision Impairment One of the most important ways to support accessibility is to make sure your app is accessible to users with vision impairments. As mentioned previously, one way to support users with trouble seeing content on small screens is to always use scalable pixels (sp) as units on TextViews. This allows the size of the content to scale with user preferences: so if someone wants everything on the phone to be large, it can be! However, users who are blind require extra support. This support is provided by Accessibility Services, which are “background services” that can respond to specific accessibility events (we will discuss Services more in a future lecture). The most common built-in service is called TalkBack, which is the Google-developed screen reader for Android. This service will “speak” the name of UI elements as the user focuses on them, as well as allow the user to drag a finger around a screen and get verbal feedback of what is there. TalkBack can be turned enabled by going to Settings &gt; Accessibility &gt; TalkBack. This service is available on most consumer devices, but will need to be installed manually on the emulator. You can download the packaged .apk from here (version 5.1.0 works fine), and install it on the emulator using adb on the Terminal: # replace with the package-name adb install package-name.apk Turn on TalkBack and use it to explore your phone and the test the Loader Demo app. You should do this without looking at your phone (avert you eyes, flip it upside down, etc)—try acting as if you were blind but still need to use the device! The TalkBack service will start with a tutorial that you can complete (you can also read the user documentation). In short: drag your finger to browse the device (letting TalkBack tell you what you are selecting), and then double-tap to “click” on an element. As you should notice in testing your app, many interface designs give usability hints (e.g., what a button does) though visual cus: images, icons, and labels. While this may cause the app to “look” nice, it is not very effective for vision-impaired users—such as how the “icon” buttons are just explored as (e.g.) “Button 59”. Thus for these purely visual elements (e.g., ImageButton, ImageView) we need to specify what text should be read by TalkBack. Do this by including an android:contentDescription attribute on these elements, which are given a value of the text that TalkBack should read. Do this for all of the visual elements in the MovieFragment layout. (You can also set this description for dynamic elements using the setContentDescription() function in Java). This is equivalent to adding an alt or ARIA attribute in HTML. Incuding the android:contentDescription attribute is an incredibly easy addition (low-hanging fruit!) that does quite a lot to support accessibility of Android apps. 11.2.2 Supporting Alternative Inputs A second easy change involves supporting interaction that doesn’t use the Touch Screen. This could be because of physical limitations: the user may interact with the device through an external device such as a keyboard, trackball, or switch. The best way to support these alternative inputs is by making sure that each navigational element (things the user may select) are focusable. You can do this by specifying the android:focusable attribute in the XML (or use the View#setFocusable() method in Java). Buttons are already focusable by default. But you can also specify the order by whch elements get focus (similar to the “tab order” in HTML). This is done using XML attributes android:nextFocusDown, android:nextFocusUp, android:nextFocusLeft, android:nextFocusRight. Each of these takes an id reference as a value (e.g., &quot;@id/nextElement&quot;), which refers to which View should gain focus instead of the “natural” order. To practice this, modify the focus order so that the the “search input” has focus first, with the “search button” gaining focus on down from there and the “clear button” gaining focus on up. In order to test this, you will need to make sure your device supports a physical keyboard and/or D-Pad, but you can also use the arrow keys for the emulator. 11.2.3 Supporting Internationalization Finally you can make an application accessible to a wider diversity of users by providing Internationalization and supporting different languages and cultures. Internationalization (i18n) is primarily done by specifying alternative resource, such as using XML to define user-facing Strings in multiple languages. We did an example of this in lecture 3 However, changes in language may also require adjustments to the layout resources themselves: phrases in some languages are significantly longer or shorter than in English, and so may cause problems with spacing or word wrapping. One way to test this is to enable pseudo-localization, a “fake” language that almost looks like English, but utilizes special characters and extraneous text to help test what the application may look like with different length content. See the link for details on enabling this. Another significant change involves support right-to-left (RTL) languages such as Arabic. With these languages the “flow” of text goes in the opposite direction than in English, so many positioning elements in layouts may need to be reversed: English and Arabic layouts. Image by Ryder Ziola. In particular, do the following to best support both LTR and RTL languages: Declare that your app supports RTL in the Manifest by including an attribute android:supportsRtl=&quot;true&quot; in the &lt;application&gt; element. With RelativeLayouts, use positioning attributes based on start and end rather than left and right. For example, android:layout_toRightOf should instead be android:layout_toEndOf. This will allow the relative positioning to automatically “switch” between LTR and RTL. Note that LinearLayouts automatically reverse direction! For custom icons and drawables: define separate resources for LTR and RTL (use the ldrtl resource qualitifier to specify the “layout direction” as right-to-left). This will allow for icons (such as the arrows in the upper start corner of the example) to change direction with the text—you want “back” to actually point “back”! Make these changes to the MovieFragment (there are no custom drawables to adjust). You can test that your changes work by selecting Settings &gt; Developer options &gt; Force RTL layout direction. 11.2.4 Further Testing These are fairly trivial changes you can make to how you define and implement user interfaces, that will go a long way to supporting use by all users no matter their level of ability. The Android Studio IDE will identify and suggest additional changes as “linted” style suggestions—watch out for these warnings and learn to correct them as you develop. Finally, Google has also developed an Accessibility Scanner app that can be used to check for further accessibility issues (such as contrast levels or touchable areas). And of course, keep the checklist handy to help you design applications to support universal usability. "],
["fragments-viewpager.html", "Lecture 12 Fragments: ViewPager 12.1 Define a SearchFragment 12.2 Add the ViewPager and Adapter 12.3 Add User Interaction", " Lecture 12 Fragments: ViewPager In this chapter, you will practice working with Fragments and layouts. Specifically, you will modify the Movie application so that it uses a ViewPager, an interactive View offered by the Android Support Library that will allow you to “page” (swipe) through different Fragments. You will modify the application so that the user can swipe through a “search” screen, the list of search results, and the details about a particular movie. IMPORTANT NOTE: you should not modify the MovieFragment or the DetailFragment (those Fragments are self-contained and so can be used in multiple layouts!). You will need to create one new Fragment though, and make substantial modifications to the MainActivity This chapter will build on the lecture code found at https://github.com/info448-s17/lecture05-fragments. If you haven’t already, you should Fork and Clone this repo in order to complete the tutorial. Note that you should complete this tutorial on a separate viewpager-work branch. You can create this branch either off of the completed branch (containing the completed lecture code), or from the master branch of code if you were able to complete the work described in lecture 5: git checkout completed git checkout -b lab-work 12.1 Define a SearchFragment Your ViewPager will need to support three different Fragments. While the MovieFragment and DetailFragment are defined already, you will need to create a third. Create a new Fragment called SearchFragment (use the File &gt; New &gt; Fragment &gt; Fragment (Blank) menu in Android Studio). Your SearchFragment will need to include the following components The layout for the Fragment should contain the seach EditText and Button taken from the activity_main layoout. You can add some layout_gravity to center the inputs. You can also remove the onClick XML attribute, as click handling will be specified in the Java In the SearchFragment class, be sure to define a newInstance() factory method. The method doesn’t need to take any arguments (and thus you don’t need to specify an argument bundle). Typing newInstance will allow Android Studio to tab-complete the method! The SearchFragment will need to communicate with other Fragments, and thus you will need to define an interface (e.g., OnSearchListener) that the containing Activity can implement. This interface should support a single public method (e.g., onSearchSubmitted(String searchTerm)) which will allow the Fragment to pass the entered search term to the Activity. Remember to check that the containing Activity implements the interface in the Fragment’s onAttach() callback. Finally, in the onCreateView() callback, add a click listener to the button so that when it is clicked, it calls the onSeachSubmitted() callback function on the containing Activity (which you’ve established has that method!) Remember that you can call findViewById() on the root view. 12.2 Add the ViewPager and Adapter Your MainActivity will need to contain a ViewPager View (since all the other Views have been moved to Fragments!). Add a android.support.v4.view.ViewPager element in the activity_main.xml layout resource, finding this View in the Activity’s onCreate() callback. Just like with a ListView, a ViewPager requires a (custom) adapter in order to map from which “page” is shown to the Fragment that is rendered. Add a new inner class (e.g., MoviePagerAdapter) that subclasses FragmentStatePagerAdapter. As in the documentation example, You will need to provide a constructor that takes in a (Support) FragmentManager, and calls the appropriate super constructor. The getItem() function returns which Fragment is shown for a particular page number. You should implement this function so that page 0 shows a SearchFragment, page 1 shows a MoviesFragment, and page 2 shows a DetailsFragment. You can declear each of these three Fragments as instance variables, then simply return them from this method. It’s okay to “hard-code” this logic for the purposes of this demonstration. The getCount() function returns how many pages the Pager supports. Note that you will need to include some logic for this: before a search has occured, there is only one page! After the search, there are two pages (the search and the results), and after a result option is selected there are three pages (the search, the results, and the details). Finally, we will be “replacing” Fragments inside the Pager as the user interacts with the app (e.g., changing the MoviesFragment to one with different search results)—such as by changing the objects that the instance variables refer to. However, the ViewPager “preloads” adjacent Fragment pages as an optimization technique; thus it “caches” the Fragments and won’t actually load any updated Views. As a work-around, override the getItemPosition() function (which is called whenever the Pager needs to determine if an item’s position has changed): public int getItemPosition(Object object) { return POSITION_NONE; } Note that this is a memory-intensive workaround (but works for demonstration purposes); for a cleaner solution, see this discussion. Once you’ve defined the your adapter, instantiate it in the Activity’s onCreate() callback, and use ViewPager#setAdapter() to specify the Pager’s adapter. If you also instantiate a SearchFragment in the onCreate() callback, then you should be able to run the application and see that Fragment appear as a page (though there is nothing else to swipe to yet). 12.3 Add User Interaction Finally, you will need to adjust the Fragment callback methods inside the Activity (e.g., onSearchSubmitted() and onMovieSelected()) so that they interact with the ViewPager. Note that this will involve removing previous code (the ViewPager does not need to utilize FragmentTransactions). When the search term is submitted from the SearchFragment, your Activity should instantiate a new (potentially different) MoviesFragment result list for that search term. The PagerAdapter should return an appropriate page count depending on whether a result list has been instantiated or not. However, simply creating a different Fragment will not cause the Adapter to change—you need to let the Adapter know that the model it is adapting into a view has changed! You can do this by calling the notifyDataSetChanged() method on the adapter. After you’ve modified (and notified!) the Adapter, you can change which page is displayed using the ViewPager#setCurrentItem() method. This will let you take the user to the “results” page! Similarly, modify the movie selection callback so that when a movie is selected from the list, your Activity instantiates a new (potentially different) DetailFragment. Remember to notify the adapter that the data set has changed, and to change which page is currently shown. This will replace the previous behavior of the callback. Once you’ve made these changes, you should be able to search for movies, see the results, and view the details for movies. Swipe left and right to navigate between pages! "],
["bluetooth.html", "Lecture 13 Bluetooth", " Lecture 13 Bluetooth In this chapter you will learn about some of the pieces for creating a connection between two co-located devices using Bluetooth. This will let you gain some familiarity with the Bluetooth API, as well as further practice working with Intents. The code for this tutorial can be found at https://github.com/info448-s17/lab-bluetooth. This tutorial involves filling in the remaining pieces from a Sample Project provided by Google. Google includes lots of samples demonstrating how to use particular pieces of functionality; reading and adapting the provided projects is a great way to learn new skills. There are a lot of comments, though that sometimes makes it hard to follow all the pieces. Read carefully! Also be sure to open the API documentation for reference! The emulator doesn’t support Bluetooth, so you will need to run this project on a physical device. Your task is to fill in the missing pieces of code, following the instructions below. I’ve marked each location with a TODO comment, which should show up in blue in Android Studio. Start by reading through The Basics to get a sense for what classes will be used and what their roles are. You only need to focus on the first 4: BluetoothAdapter, BluetoothDevice, BluetoothSocket, and BluetoothServerSocket (the rest are for other kinds of Bluetooth connections, like audio transfer and stuff). You don’t need to know all the methods or details of these classes, but should be familiar with their general, one-sentence purposes! You’ll need to request permission to use Bluetooth. Add the appropriate &lt;uses-permission&gt; attributes: one for BLUETOOTH (for communication; included) and one for BLUETOOTH_ADMIN (to “discover” devices and make connections). The main UI is defined in the BluetoothChatFragment class, which is a Fragment that holds the chat system. Start by filling in the onCreate() callback by fetching the default Bluetooth adapter and saving it to an instance variable (mBluetoothAdapter). If the adapter doesn’t exist (is null), you should Toast a message that Bluetooth isn’t available (using the Activity's Application Context so that the Toast lasts), and then call finish() on the Fragment’s Activity (to close the application). You’ll want your app to make sure that the user has Bluetooth turned on. In the Fragment’s onCreate(), check whether the the BluetoothAdapter is enabled. If not, you’ll want to prompt the user to enable it, such as by launching the “Settings” app. Create an Implicit Intent for the action BluetoothAdapter.ACTION_REQUEST_ENABLE, and send this Intent for a result (with the result code of REQUEST_ENABLE_BT). Look in the Fragment’s onActivityResult() method to see what happens when we get a response back! The BluetoothChatService (stored in the instance variable mChatService) is an object representing a “background service”—think an AsyncTask but with a much longer lifespan. This particular service handles sending bytes of data back and forth over Bluetooth. We’ll talk about Services more later in the course. In order for a device to connect to yours over Bluetooth, your device will need to be discoverable: effectively, it has to respond to public queries about its existence (sort of like having your instant messaging status as “Online/Available”). In the Fragment’s ensureDiscoverable() helper method, check if the device is currently discoverable by calling getScanMode() on the BluetoothAdapter; it should return a value of BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE. If this IS NOT the case, then you should send another Implicit Intent to handle the BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE action. This intent should include (put) an extra that has the key BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION and a value of 300, so that we are in “discoverable” mode for 300 seconds. Note that this intent does NOT need to be started for a result! The discovery of devices is controlled by the DeviceListActivity Activity. This is a separate Activity that will actually appear as a popup dialog (though it doesn’t use DialogFragment; it just “themes” the Activity as a dialog in the Manifest). The Activity’s onCreate() does a lot of UI work (including setting up an Adapter!), but it also needs to set up a BroadcastReceiver to listen for events like when devices are found. (This is the equivalent of declaring a &lt;receiver&gt; and &lt;intent-filter&gt; in the Manifest, but we need to do it in Java since the Receiver isn’t a separate class and since we want to do it dynamically). First instantiate a new IntentFilter object (giving it the BluetoothDevice.ACTION_FOUND action). Then use the registerReceiver(receiver, intentFilter) method, passing it the already-existing receiver (mReceiver) and the IntentFilter you just created! Then repeat the above two steps, but this time for the Bluetooth.ACTION_DISCOVERY_FINISHED action. This will register an additional IntentFilter on the same receiver. We can actually begin searching for devices by filling in the Activity’s doDiscovery() helper method (which is called when the Scan button is pressed). Add a check to see if the BluetoothAdapter currently isDiscovering(). If so, then you should tell the adapter to cancelDiscovery(). Whether or not the check was true (so even if we canceled the discovery), tell the adapter to startDiscovery() to begin searching for devices! Once the user has selected a device to connect to, we handle that connection back in the BluetoothChatFragment. Fill in that class’s connectDevice() helper method to connect to the device! First you’ll want to get the device’s “address” (a MAC address that acts as a unique identifier) from the Intent’s extras: get the Bundle of extras from the Intent, then get the String with the key DeviceListActivity.EXTRA_DEVICE_ADDRESS. You can then find the device (a BluetoothDevice object) by calling the .getRemoteDevice() method on the BluetoothAdapter and passing this address. Finally, you can use the mChatService’s .connect() method to connect to this device (passing down the secure option as a second parameter). The BluetoothChatService#connect() method creates a new Thread to do the communication work, and opens up network sockets so that messages can be passed between the devices. (This is actually part of the hard part or working with Bluetooth; luckily we have a class to abstract that for us!) The last part is to actually send a message! In the sendMessage() helper in BluetoothChatFragment, fill in the details so that the String can be sent to the socket in the chat service. First you need to convert the message String into a byte[] (for communication over the socket). Use the String’s getBytes() method to convert. Then you can tell mChatService to .write() those bytes! We then need to reset the mOutStringBuffer instance variable (which keeps track of the message that has been typed so far). Use .setLength() to give it a length of 0, which will effectively make it empty. And finally, because we’ve changed the outgoing message, set the text of the mOutEditText TextView to be the (now empty) mOutStringBuffer. And that’s it! You should now have a working chat system! Search for and connect to someone else’s device and try saying “hello”! "],
["maps.html", "Lecture 14 Maps 14.1 Create a Map Activity 14.2 Specifying the User Interface 14.3 Markers and Drawings", " Lecture 14 Maps This chapter will introduce you to the Google Maps Android API which allows you to very easily add an interactive map to your application. 14.1 Create a Map Activity There is no scaffolding code for this tutorial; instead, you should create a new project from scratch. Note that you can test your project either on the emulator or a physical device: just make sure the device has the Google APIs included. Start a new project in Android Studio (“Map Lab” is a fine project name). Target SDK 15 like usual. But here’s where things get different! Instead of starting with an “Empty Activity”, start with a Google Maps Activity. This will create you a new Activity whose layout includes an XML-defined SupportMapFragment. (This is just another Fragment subclass, so you could include it in a layout however you wanted. You can stick with the default layout for now). 14.1.1 Getting an API Key In order to access and show a Google Map, you need to register and get an API key (this is like a special password that lets your app access Google’s map data). When you create the Maps Activity, Android Studio should open up the google_maps_api.xml resource file. This file contains instructions on how to get an API key (i.e., paste the giant pre-generated link into your browser, and then copy the generated key into the XML resource). The instructions found in the google_maps_api.xml file. (If you already have a Google Maps API Key, you can add this package &amp; device to that key in the Google Developer Console). After you’ve entered the key, you should be able to build and run your app, and see a displayed map! 14.1.2 The SupportMapFragment Take a moment to open up the generated MapsActivity and its associated layout (by default layouts/activity_maps.xml) and read over the initial code. The layout resource contains a single &lt;fragment&gt; element (like we’ve defined before), in this case referring to an instance of the SupportMapFragment class. This fragment represents the interactive map. It’s just a subclass of Fragment (with a few extra methods), so everything we’ve learned about Fragments applies. The Fragment is defined in the XML, so we don’t need to use a FragmentTransaction to add it in the Java code. But we do use the FragmentManager to get access to that fragment so that we can call a single method on it: getMapAsync(). This gets access to a GoogleMap object, which does all the work of downloading map tiles, handling pans and zooms, and drawing markers and shapes. The getMapAsync() method loads this object asynchronously (like we’ve with the GoogleApiClient), and will notify a listener when the object is available. Because the MapsActivity implements the OnMapReadyCallback interface, it is a listener and so its onMapReady() callback will be called and passed the object for us to handle. Once the the object is available via the callback, we can start calling methods on it: e.g., to show a marker at a particular latitude/longitude (LatLng), and to position the map’s “camera” to focus on that spot. 14.2 Specifying the User Interface The Java code is able to position the map, but if we want to specify a “default” position, you should instead do that work in the Fragment’s definition in the XML resource file. Check out the list of available XML attributes for defining the user interface of your map. Customize the map so that: It is by default centered on Mary Gates Hall. (You will need to delete the positioning Java code so that doesn’t override your XML). It is zoomed in so that we can see the see the whole fountain on the map Make the map shows the “zoom control buttons” (so that you can zoom in using the emulator!) Make the map show both satellite imagery and roads/buildings. 14.3 Markers and Drawings Showing a map is great, but what we really want to do is customize what it shows: that is, we want to draw on it! There are a couple of things we can draw, one of the most common of which is Markers that indicate a single location on the map. You can create a Marker by instantiating a new MarkerOptions object and passing it into the GoogleMap object’s addMarker() method. See the documentation for ways to customize these markers. The most common options are setting the position (required), the title (text that appears when the user clicks the marker), and snippet (additional text). Create a marker centered in the center of the fountain. The marker should be purple or gold in color, and clicking on it should tell the user something about the ducks who dwell there! You can show customized information (including pictures, etc) when markers are clicked using Info Windows. 14.3.1 Drawing Shapes You can also draw free-form shapes on the map, anchored to particular locations. These include lines, circles, and generic polygons. One of the best options for drawing is the Polyline, which is a series of connected line segments (like a “path” in SVG). In order to create a Polyline, you actually instantiate a PolylineOptions object. You can add() points (LatLng objects) to this object, extending the line from one point to the next. This PolylineOptions object is then passed to the GoogleMap object’s addPolyline() method. You can also specify other visual properties such as the color and the width of the Polyline. Note that the width is measure in screen pixels—it will be the same no matter what zoom level you are at! (If you wanted it to change dynamically, you’d need to do that work on your own). Using a Polyline, draw a giant “W” in either purple or gold centered on the fountain. Bonus if want to make it look like the UW logo! Or better yet: can you use a combination of Polylines, Circles, and Polygons to draw an approximation of the iSchool logo? "],
["java-review.html", "A Java Review A.1 Building Apps with Gradle A.2 Class Basics A.3 Inheritance A.4 Interfaces A.5 Polymorphism A.6 Abstract Methods and Classes A.7 Generics A.8 Nested Classes", " A Java Review Android applications are written primarily in the Java Language. This appendix contains a review of some Java fundamentals needed when developing for Android, presented as a set of practice exercises. The code for these exercises can be found at https://github.com/info448-s17/lab-java-review. A.1 Building Apps with Gradle Consider the included Dog class found in the src/main/java/edu/info448/review/ folder. This is a very basic class representing a Dog. You can instantiate and call methods on this class by building and running the Tester class found in the same folder. - You can just use any text editor, like VS Code, Atom, or Sublime Text to view and edit these files. You’ve probably run Java programs using an IDE, but let’s consider what is involved in building this app “by hand”, or just using the JDK tools. There are two main steps to running a Java program: Compiling This converts the Java source code (in .java files) into JVM bytecode that can be understood by the virtual machine (in .class) files. Running This actually loads the bytecode into the virtual machine and executes the main() method. Compiling is done with the javac (“java compile”) command. For example, from inside the code repo’s directory, you can compile both the .java files with: # Compile all .java files javac src/main/java/edu/info448/review/*.java Running is then done with the java command: you specify the full package name of the class you wish to run, as well as the classpath so that Java knows where to go find classes it depends on: # Runs the Tester#main() method with the `src/main/java` folder as the classpath java -classpath ./src/main/java edu.info448.review.Tester Practice: Compile and run this application now. Practice: Modify the Dog class so that it’s .bark() method barks twice (&quot;Bark Bark!&quot;). What do you have to do to test that your change worked? You may notice that this development cycle can get pretty tedious: there are two commands we need to execute to run our code, and both are complex enough that they are a pain to retype. Enter Gradle. Gradle is a build automation system: a “script” that you can run that will automatically perform the multiple steps required to build and run an application. This script is defined by the build.gradle configuration file. Practice: open that file and look through its contents. The task run() is where the “run” task is defined: do you see how it defines the same arguments we otherwise passed to the java command? You can run the version of Gradle included in the repo with the gradlew &lt;task&gt; command, specifying what task you want to the build system to perform. For example: # on Mac/Linux ./gradlew tasks # on Windows gradlew tasks Will give you a list of available tasks. Use gradlew classes to compile the code, and gradlew run to compile and run the code. Helpful hint: you can specify the “quite” flag with gradlew -q &lt;task&gt; to not have Gradle output its build status (handy for the run task) Practice: Use gradle to build and run your Dog program. See how much easier that is? We will be using Gradle to build our Android applications (which are much more complex than this simple Java demo)! A.2 Class Basics Now consider the Dog class in more detail. Like all classes, it has two parts: Attributes (a.k.a., instance variables, fields, or member variables). For example, String name. Notice that all of these attributes are private, meaning they are not accessible to members of another class! This is important for encapsulation: it means we can change how the Dog class is implemented without changing any other class that depends on it (for example, if we want to store breed as a number instead of a String). Methods (a.k.a., functions). For example bark() Note the method declaration public void wagTail(int). This combination of access modifier (public), return type (void), method name (wagTail) and parameters (int) is called the method signature: it is the “autograph” of that particular method. When we call a method (e.g., myDog.wagTail(3)), Java will look for a method definition that matches that signature. Method signatures are very important! They tell us what the inputs and outputs of a method will be. We should be able to understand how the method works just from its signature. Notice that one of the methods, .createPuppies() is a static method. This means that the method belongs to the class, not to individual object instances of the class! Practice: try running the following code (by placing it in the main() method of the Tester class): Dog[] pups = Dog.createPuppies(3); System.out.println(Arrays.toString(pups)); Notice that to call the createPuppies() method you didn’t need to have a Dog object (you didn’t need to use the new keyword): instead you went to the “template” for a Dog and told that template to do some work. Non-static methods (ones without the static keyword, also called “instance methods”) need to be called on an object. Practice: Try to run the code Dog.bark(). What happens? This is because you can’t tell the “template” for a Dog to bark, only an actual Dog object! In general, in 98% of cases, your methods should not be static, because you want to call them on a specific object rather than on a general “template” for objects. Variables should never be static, unless they are also final constants (like the BEST_BREED variable). In Android, static variables cause significant memory leaks, as well as just being generally poor design. A.3 Inheritance Practice: Create a new file Husky.java that declares a new Husky class: package edu.info448.review; //package declaration (needed) public class Husky extends Dog { /* class body goes here */ } The extends keyword means that Husky is a subclass of Dog, inheriting all of its methods and attributes. It also means that that a Husky instance is a Dog instance. Practice: In the Tester, instantiate a new Husky and call bark() on it. What happens? Because we’ve inherited from Dog, the Husky class gets all of the methods defined in Dog for free! Try adding a constructor that takes in a single parameter (name) and calls the appropriate super() constructor so that the breed is &quot;Husky&quot;, which makes this a little more sensible. We can also add more methods to the subclass that the parent class doesn’t have. Practice: add a method called .pullSled() to the Husky class. Try calling .pullSled() on your Husky object. What happens? Then try calling .pullSled() on a Dog object. What happens? Finally, we can override methods from the parent class. Practice: add a bark() method to Husky (with the same signature), but that has the Husky “woof” instead of “bark”. Test out your code by calling the method in the Tester. A.4 Interfaces Practice: Create a new file Huggable.java with the following code: package edu.info448.review; public interface Huggable { public void hug(); } This is an example of an interface. An interface is a list of methods that a class promises to provide. By implementing the interface (with the interface keyword in the class declaration), the class promises to include any methods listed in the interface. This is a lot like hanging a sign outside your business that says “Accepts Visa”. It means that if someone comes to you and tries to pay with a Visa card, you’ll be able to do that! Implementing an interface makes no promise about what those methods do, just that the class will include methods with those signatures. Practice: change the Husky class declaration: java public class Husky extends Dog implements Huggable {...} Now the the Husky class needs to have a public void hug() method, but what that method does is up to you! A class can still have a .hug() method even without implementing the Huggable interface (see TeddyBear), but we gain more benefits by announcing that we support that method. Just like how hanging an “Accepts Visa” sign will bring in more people who would be willing to pay with a credit card, rather than just having that option available if someone asks about it. Why not just make Huggable a superclass, and have the Husky extend that? Because Husky extends Dog, and you can only have one parent in Java! And because not all dogs are Huggable, and not all Huggable things are Dogs, there isn’t a clear hierarchy for where to include the interface. In addition, we can implement multiple interfaces (Husky implements Huggable, Pettable), but we can’t inherit from multiple classes This is great for when we have other classes of different types but similar behavior: e.g., a TeddyBear can be Huggable but can’t bark() like a Dog! Practice: Make the class TeddyBear implement Huggable. Do you need to add any new methods? What’s the difference between inheritance and interfaces? The main rule of thumb: use inheritance (extends) when you want classes to share code (implementation). Use interfaces (implements) when you want classes to share behaviors (method signatures). In the end, interfaces are more important for doing good Object-Oriented design. Favor interfaces over inheritance! A.5 Polymorphism Implementing an interface also establishes an is a relationship: so a Husky object is a Huggable object. This allows the greatest benefit of interfaces and inheritance: polymorphism, or the ability to treat one object as the type of another! Consider the standard variable declaration: Dog myDog; //= new Dog(); The variable type of myDog is Dog, which means that variable can refer to any value (object) that is a Dog. Practice: Try the following declarations (note that some will not compile!) Dog v1 = new Husky(); Husky v2 = new Dog(); Huggable v2 = new Husky(); Huggable v3 = new TeddyBear(); Husky v4 = new TeddyBear(); If the value (the thing on the right side) is an instance of the variable type (the type on the left side), then you have a valid declaration. Even if you declare a variable Dog v1 = new Husky(), the value in that object is a Husky. If you call .bark() on it, you’ll get the Husky version of the method (Practice: try overriding the method to print out &quot;barks like a Husky&quot; to see). You can cast between types if you need to convert from one to another. As long as the value is a instance of the type you’re casting to, the operation will work fine. Dog v1 = new Husky(); Husky v2 = (Husky)v1; //legal casting The biggest benefit from polymorphism is abstraction. Consider: ArrayList&lt;Huggable&gt; hugList = new ArrayList&lt;Huggable&gt;(); //a list of huggable things hugList.add(new Husky()); //a Husky is Huggable hugList.add(new TeddyBear()); //so are Teddybears! //enhanced for loop (&quot;foreach&quot; loop) //read: &quot;for each Huggable in the hugList&quot; for(Huggable thing : hugList) { thing.hug(); } Practice: What happens if you run the above code? Because Huskies and Teddy Bears share the same behavior (interface), we can treat them as a single “type”, and so put them both in a list. And because everything in the list supports the Huggable interface, we can call .hug() on each item in the list and we know they’ll have that method—they promised by implementing the interface after all! A.6 Abstract Methods and Classes Take another look at the Huggable interface you created. It contains a single method declaration… followed by a semicolon instead of a method body. This is an abstract method: in fact, you can add the abstract keyword to this method declaration without changing anything (all methods are interfaces are implicitly abstract, so it isn’t required): public abstract void hug(); An abstract method is one that does not (yet) have a method body: it’s just the signature, but no actual implementation. It is “unfinished.” In order to instantiate a class (using the new keyword), that class needs to be “finished” and provide implementations for all abstract methods—e.g., all the ones you’ve inherited from an interface. This is exactly how you’ve used interfaces so far: it’s just another way of thinking about why you need to provide those methods. If the abstract keyword is implied for interfaces, what’s the point? Consider the Animal class (which is a parent class for Dog). The .speak() method is “empty”; in order for it to do anything, the subclass needs to override it. And currently there is nothing to stop someone who is subclassing Animal from forgetting to implement that method! We can force the subclass to override this method by making the method abstract: effectively, leaving it unfinished so that if the subclass (e.g., Dog) wants to do anything, it must finish up the method. Practice: Make the Animal#speak() method abstract. What happens when you try and build the code? If the Animal class contains an unfinished (abstract) method… then that class itself is unfinished, and Java requires us to mark it as such. We do this by declaring the class as abstract in the class declaration : public abstract class MyAbstractClass {...} Practice: Make the Animal class abstract. You will need to provide an implementation of the .speak() method in the Dog class: try just having it call the .bark() method (method composition for-the-win!). Only abstract classes and interfaces can contain abstract methods. In addition, an abstract class is unfinished, meaning it can’t be instantiated. Practice: Try to instantiate a new Animal(). What happens? Abstract classes are great for containing “most” of a class, but making sure that it isn’t used without all the details provided. And if you think about it, we’d never want to ever instantiate a generic Animal anyway—we’d instead make a Dog or a Cat or a Turtle or something. All that the Animal class is doing is acting as an abstraction for these other classes to allow them to share implementations (e.g., of a walk() method). Abstract classes are a bit like “templates” for classes… which are themselves “templates” for objects. A.7 Generics Speaking of templates: think back to the ArrayList class you’ve used in the past, and how you specified the “type” inside that List by using angle brackets (e.g., ArrayList&lt;Dog&gt;). Those angle brackets indicate that ArrayList is a generic class: a template for a class where a data type for that class is itself a variable. Consider the GiftBox class, representing a box containing a TeddyBear. What changes would you need to make to this class so that it contains a Husky instead of a TeddyBear? What about if it contained a String instead? You should notice that the only difference between TeddyGiftBox and HuskyGiftBox and StringGiftBox would be the variable type of the contents. So rather than needing to duplicate work and write the same code for every different type of gift we might want to give… we can use generics. Generics let us specify a data type (e.g., what is currently TeddyBear or String) as a variable, which is set when we instantiate the class using the angle brackets (e.g., new GiftBox&lt;TeddyBear&gt;() would create an object of the class with that type variable set to be TeddyBear). We specify generics by declaring the data type variable in the class declaration: public class GiftBox&lt;T&gt; {...} (T is a common variable name, short for “Type”. Other options include E for Elements in lists, K for Keys and V for Values in maps). And then everywhere you would have put a datatype (e.g., TeddyBear), you can just put the T variable instead. This will be replace by an actual type at compile time. Warning: always use single-letter variable names for generic types! If you try to name it something like String (e.g., public class GiftBox&lt;String&gt;), then Java will interpret the word String to be that variable type, rather than refering to the java.lang.String class. This a lot like declaring a variable int Dog = 448, and then calling Dog.createPuppies(). Practice: Try to make the GiftBox class generic and instantiate a new GiftBox&lt;Husky&gt; A.8 Nested Classes One last piece: we’ve been putting attributes and methods into classes… but we can also define additional classes inside a class! These are called nested or inner classes. We’ll often nest “helper classes” inside a bigger class: for example, you may have put a Node class inside a LinkedList class: public class LinkedList { //nested class public class Node { private int data; public Node(int data) { this.data = data; } } private Node start; public LinkedList() { this.start = new Node(448); } } Or maybe we want to define a Smell class inside the Dog class to represent different smells, allowing us to talk about different Dog.Smell objects. (And of course, the Dog.Smell class would implement the Sniffable interface…) Nested classes we define are usually static: meaning they belong to the class not to object instances of that class. This means that there is only one copy of that nested blueprint class in memory; it’s the equivalent to putting the class in a separate file, but nesting lets us keep them in the same place and provides a “namespacing” function (e.g., Dog.Smell rather than just Smell). Non-static nested classes (or inner classes) on the other hand are defined for each object. This is important only if the behavior of that class is going to depend on the object in which it lives. This is a subtle point that we’ll see as we provide inner classes required by the Android framework. "],
["java-swing.html", "B Swing Framework B.1 Events B.2 Layouts and Composites", " B Swing Framework Android applications are user-driven graphical applications. In order to become familiar with some of the coding patterns involved in this kind of software (without the overhead of the Android framework), let’s consider how to build simple graphical applications in Java using the Swing library This appendix references code found at https://github.com/info448-s17/lecture02-activities, in the java/ folder. Note that this tutorial involves Java Programming: while it is possible to do this in Android Studio, it’s often easier to just utilize a light-weight text editor such as Visual Studio Code or Sublime Text. The Swing library is a set of Java classes used to specify graphical user interfaces (GUIs). These classes can be found in the javax.swing package. They also rely on the java.awt package (the “Advanced Windowing Toolkit”), which is an older GUI library that Swing builds on top of. Fun fact: Swing library is named after the dance style: the developers wanted to name it after something hip and cool and popular. In the mid-90s. Let’s look at an incredibly basic GUI class: MyGUI found in the src/main/java/ folder. The class subclasses (extends) JFrame. JFrame represents a “window” in your operating system, and does all the work of making that window show up and interact with the operating system in a normal way. By subclassing JFrame, we get that functionality for free! This is how we build all GUI applications using this framework. Most of the work defining a Swing GUI happens in the JFrame constructor (called when the GUI is “created”). We first call the parent constructor (passing in the title for the window), and then call a method to specify what happens when we hit the “close” button. We then instantiate a JButton, which is a class representing a Java Button. Note that JButton is the Swing version of a button, building off of the older java.awt.Button class. We then .add() this button to the JFrame. This puts the button inside the window. This process is similar to using jQuery to add an HTML element to web page. Finally, we call .pack() to tell the Frame to resize itself to fit the contents, and then .setVisible() to make it actually appear. We run this program from main by just instantiating our specialized JFrame, which will contain the button. You can compile and run this program with ./gradlew -q run. And voila, we have a basic button app! B.1 Events If we click the button… nothing happens. Let’s make it print out a message when clicked. We can do this through event-based programming (if you remember handling click events from JavaScript, this is the same idea). Most computer systems see interactions with its GUI as a series of events: the event of clicking a button, the event of moving the mouse, the event of closing a window, etc. Each thing you interact with generates and emits these events. So when you click on a button, it creates and emits an “I was clicked!” event. (You can think of this like the button shouting “Hey hey! I was pressed!”) We can write code to respond to this shouting to have our application do something when the button is clicked. Events, like everything else in Java, are Objects (of the EventObject type) that are created by the emitter. A JButton in particular emits ActionEvents when pressed (the “action” being that it was pressed). In other words, when buttons are pressed, they shout out ActionEvents. In order to respond to this shouting, we need to “listen” for these events. Then whenever we hear that there is an event happening, we can react to it. This is like a person manning a submarine radar, or hooking up a baby monitor, or following someone on Twitter. But this is Java, and everything in Java is based on Objects, we need an object to listen for these events: a “listener” if you will. Luckily, Java provides a type that can listen for ActionEvents: ActionListener. This type has an actionPerformed() method that can be called in response to an event. We use the Observer Pattern to connect this listener object to the button (button.addActionListener(listener)). This registers the listener, so that the Button knows who to shout at when something happens. (Again, like following someone on Twitter). When the button is pressed, it will go to any listeners registered with it and call their actionPerformed() methods, passing in the ActionEvent it generated. But look carefully: ActionListener is not a concrete class, but an abstract interface. This means if we want to make an ActionListener object, we need to create a class that implements this interface (and provides the actionPerformed() method that can be called when the event occurs). There are a few ways we can do this: We already have a class we’re developing: MyGUI! So we can just make that class implement ActionListener. We’ll fill in the provided method, and then specify that this object is the listener, and voila. This is my favorite way to create listeners in Java (since it keeps everything self-contained: the JFrame handles the events its buttons produce). We’ll utilize a variant of this pattern in Android: we’ll make classes implement listeners, and then “register” that listener somewhere else in the code (often in a nested class). But what if we want to reuse our listener across different classes, but don’t want to have to create a new MyGUI object to listen for a button to be clicked? We can instead use an inner or nested class. For example, create a nested class MyActionListener that implements the interface, and then just instantiate one of those to register with the button. This could be a static nested class, but then it wouldn’t be able to access instance variables (because it belongs to the class, not the object). So you might want to make it an inner class instead. Of course then you can’t re-use it elsewhere without making the MyGUI (whose instance variables it referenes anyway)… but at least we’ve organized the functionality. It seems sort of silly to create a whole new MyActionListener class that has one method and is just going to be instantiated once. So what if instead of giving it a name, we just made it an anonymous class? This is similar to how you’ve made anonymous variables by instantiating objects without assigning them to named variables, you’re just doing the same thing with a class that just implements an interface. The syntax looks like: button.addActionListener(new ActionListener() { //class declaration goes in here! public void actionPerformed(ActionEvent event) { /*...*/} }); This is how buttons are often used in Android: we’ll create an anonymous listener object to respond to the event that occurs when they are pressed. B.2 Layouts and Composites What if we want to add a second button? If we try to just .add() another button… it replaces the one we previously had! This is because Java doesn’t know where to put the second button. Below? Above? Left? Right? In order to have the JFrame contain multiple components, we need to specify a layout, which knows how to organize items that are added to the Frame. We do this with the .setLayout() method. For example, we can give the frame a BoxLayout() with a PAGE_AXIS orientation to have it lay out the buttons in a vertical row. container.setLayout(new BoxLayout(container, BoxLayout.PAGE_AXIS)); container.add(theButton); container.add(otherButton); Java has different LayoutManagers that each have their own way of organizing components. We’ll see this same idea in Android. What if we want to do more complex layouts? We could look for a more complex LayoutManager, but we can actually achieve a lot of flexibility simply by using multiple containers. For example, we can make a JPanel object, which is basically an “empty” component. We can then add multiple buttons to this this panel, and add that panel to the JFrame. Because JPanel is a Component (just like JButton is), we can use the JPanel exactly as we used the JButton—this panel just happens to have multiple buttons. And since we can put any Component in a JPanel, and JPanel is itself a Component… we can create nest these components together into a tree in an example of the Composite Pattern. This allows us to create very complex user interfaces with just a simple BoxLayout! This is similar to how we can create complex web layouts just by nesting lots of &lt;div&gt; elements. "],
["java-threads-http.html", "C Threads and HTTP Requests C.1 Concurrency C.2 HTTP Requests", " C Threads and HTTP Requests This appendix introduces concepts in concurrency and threading, which are used extensively by Android though a framework-specific classes and options. For clarity, these concepts are introduced though a set of practice exercises in straight Java (though similar code can be utilized in Android). The code for these exercises can be found at https://github.com/info448-s17/lab-threads-http. Additionally, this appendix introduces the Java code used to send network requests. Android will use exactly this code, but in order to experiment with it separate from the Android framework you’ll be making network connections directly from Java. C.1 Concurrency Concurrency the process by which we have multiple processes (think: methods) running at the same time. This can be contrasted with processes that run serially, or one after another. C.1.1 An Example: Algorithm Races! As an example, note that one of the main concerns of computer science and software in general is speed: how fast will a particular program or algorithm run? For example, give two of the many sorting algorithms that have been invented, which one can sort a list of numbers more quickly? Sorting algorithms are usually covered in UW’s CSE 373 course, but don’t worry if you haven’t taken that course yet! All you need to know is that there are different techniques for sorting numbers, these techniques are given funny names, and one technique may be faster than another Consider the provided SortRacer.java class (found in the src/main/java folder). The main method for this program runs two different sorting algorithms (currently Merge Sort and Quicksort), reporting when each one is finished. Practice: Run this program using gradle: ./gradlew -q runSorts. Note that it may take a few seconds for it to build and begin running, and the sorting itself may take a few seconds! Of course, it’s not really a “race” at the moment: rather, each sorting algorithm is run serially (that is, one after another). If we really wanted them to race, we’d like the algorithms to run concurrently (at the same time). Computers as a general rule do exactly one thing a time: your central processing unit (CPU) just adds two number together over and over again, billions of times a second The standard measure for rate (how many times per second) is the hertz (Hz). So a 2 gigahertz (GHz) processor can do 2 billion operations per second. However, we don’t realize that computers do only one thing at a time! This is because computers are really good at multitasking: they will do a tiny bit of one task, and then jump over to another task and do a little of that, and then jump over to another task and do a little of that, and then back to the first task, and so on. Diagram of thread switching (source unknown) These “tasks” are divided up into two types: processes and threads. Read this brief summary of the difference between them. So by breaking up a program into threads (which are “interwoven”), we can in effect cause the computer to do two tasks at once. This is especially useful if one of the “tasks” might take a really long time–rather than blocking the application, we can let other tasks also make some progress while we’re waiting for the long task to finish. C.1.2 Threading the Race Currently the two sorting algorithms run in the same thread, one after another. You should break them into two different threads that can run concurrently, letting them actually be able to race! In Java, we create a Thread by creating a class that implements the Runnable interface. This represents a class that can be “run” in a separate thread! The run() method required by the interface acts a bit like the “main” method for that Thread: when we start the Thread running, that is the method that will get called. Practice: Create two new Runnable classes, one for each Sorting method. These should be nested classes (think: should they be static?). When each Runnable is run, you should create a new shuffled array of numbers and then call the appropriate sorting method on that list. Remember to print out when you start and finish sorting (just like is currently done in the main() method). If we just instantiate the Runnable() and call its run() method, that won’t actually execute the method on a different thread (remember: an interface is just a “sign”; we could have called the interface and method whatever we wanted and it would still compile). Instead, we execute code on a separate thread by using an instance of the Thread class. This class actually does the work of running code on a separate thread. Thread has a constructor that takes in a Runnable instance as a parameter—you pass an object representing the “code to run” to the Thread object (this is an example of the Strategy Pattern). You then can actually start the Thread by calling its .start() method (not the run method!). Practice: Modify the main() method so you create new Threads to execute each Runnable Make sure you actually start() the threads! Anonymous variables will be useful here; you don’t need to assign a variable name to the Runnable objects or even the Thread objects if you just use them directly. Now run your program! Do you see the Threads running at the same time? Try running the program multiple times and see what kind of differences you get. There are some print statements you can uncomment in the Sorting class if you want to see more concrete evidence of the Threads running concurrently. You are also welcome to try racing different sorting algorithms (you’ll want to use a smaller list of numbers, particularly for the painfully slow BubbleSort). You can even race more than two algorithms—just create additional Threads! And that’s the basics of creating Threads in Java! C.2 HTTP Requests Consider the provided MovieDownloader.java class (found in the src/main/java/ folder). This Java code (which is directly portable to Android) accesses the database at omdbapi.com, a wrapper around the IMDB API calls for getting information about movies. You can run this program with the ./gradlew -q runMovies task. It will prompt you for a movies to search for, and then print out the results (in JSON format). Practice: add descriptive comments to the downloadMovieData() method, explaining what the code does and how it works. The goal is to understand the classes and methods are that are being used here (particularly the use of HttpUrlConnection, InputStream, and BufferedReader), and demonstrate that understanding through explanatory comments. You should also pay particular attention to the use of try/catch blocks (see here for one explanation). Note that we’ll utilize this exact code in Android, so you should be familiar with what it is doing! "]
]
